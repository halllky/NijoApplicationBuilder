# データパターン解説
NijoApplicationBuilderでは非常に複雑なデータ構造のスキーマを定義することができる。
ここでは、スキーマ定義がとることのできるパターン、特に主要3モデル（DataModel, QueryModel, CommandModel）がとることのできるパターンを整理し、テストすべき因子・水準を整理する。

- [データパターン解説](#データパターン解説)
  - [用語](#用語)
    - [スキーマ定義（nijo.xml）](#スキーマ定義nijoxml)
    - [集約（Aggregate）](#集約aggregate)
      - [ルート集約（Root Aggregate）](#ルート集約root-aggregate)
      - [子集約（Child）](#子集約child)
      - [子配列（Children）](#子配列children)
    - [ツリー、集約ツリー](#ツリー集約ツリー)
    - [集約メンバー（Aggregate Member）](#集約メンバーaggregate-member)
      - [値メンバー（Value Member）](#値メンバーvalue-member)
      - [外部参照（Ref To）](#外部参照ref-to)
      - [子集約（Child）](#子集約child-1)
      - [子配列（Children）](#子配列children-1)
    - [モデル（Model）](#モデルmodel)
      - [データモデル（Data Model）](#データモデルdata-model)
      - [クエリモデル（Query Model）](#クエリモデルquery-model)
      - [コマンドモデル（Command Model）](#コマンドモデルcommand-model)
  - [主な仕様](#主な仕様)
    - [スキーマ定義](#スキーマ定義)
    - [ルート集約](#ルート集約)
    - [集約メンバー](#集約メンバー)
    - [データモデル](#データモデル)
    - [クエリモデル](#クエリモデル)
    - [コマンドモデル](#コマンドモデル)
  - [テストパターン](#テストパターン)
    - [メインケース](#メインケース)
      - [観点: データモデルの登録・更新・削除、クエリモデルの一覧検索・参照検索、コマンドモデルの基本的な挙動が正常に動作するか](#観点-データモデルの登録更新削除クエリモデルの一覧検索参照検索コマンドモデルの基本的な挙動が正常に動作するか)
    - [エッジケース](#エッジケース)
      - [観点: スキーマ定義のルート集約が0個の場合に異常を引き起こさないか](#観点-スキーマ定義のルート集約が0個の場合に異常を引き起こさないか)
      - [観点: パラメータや戻り値が存在しないコマンドモデル](#観点-パラメータや戻り値が存在しないコマンドモデル)


## 用語
NijoApplicationBuilderの仕様は世間一般で用いられる用語のみでは説明が非常に難しいため、ここに用語を定義する。
NijoApplicationBuilderの仕様はここで定義された用語を用いて説明される。

### スキーマ定義（nijo.xml）
nijo.xml それ自体、またはそれで定義されるアプリケーション1個分の定義。
スキーマ定義は0個以上複数個の集約から成る。

### 集約（Aggregate）
ルート集約（Root Aggregate）、子集約（Child）、子配列（Children）の3種類の総称。

#### ルート集約（Root Aggregate）
スキーマ定義直下に定義されるもの。
ルート集約は必ずいずれか1種類の **モデル** に属する。

#### 子集約（Child）
親集約と1対1の多重度をもつ、ネストされたオブジェクト。

#### 子配列（Children）
親集約と1対多の多重度をもつ、ネストされたオブジェクト。

### ツリー、集約ツリー
1つのルート集約とその子孫集約から成るまとまりのことをツリーと呼んでいる。

### 集約メンバー（Aggregate Member）
集約が保持するメンバー。
値メンバー（Value Member）、外部参照（RefTo）、子集約（Child）、子配列（Children）に分かれる。

#### 値メンバー（Value Member）
単一の値。
単語、文章、整数、実数、日付、日付時刻、真偽値、区分値、など。

#### 外部参照（Ref To）
集約ツリーの外側の集約への参照のこと。
例えば以下のスキーマ定義において「従業員（Root Aggregate）」から見た「部署（Children）」は「所属部署（RefTo 部署）」という外部参照の関係にある。

- 従業員（Root Aggregate）
  - **所属所属（RefTo 部署）**
- 営業区（Root Aggregate）
  - 部署（Children）

#### 子集約（Child）
子集約は、集約であると同時に、親集約から見た集約メンバーでもある。

#### 子配列（Children）
子配列は、集約であると同時に、親集約から見た集約メンバーでもある。

### モデル（Model）
そのルート集約からどういったソースコードが生成されるかを表す種類。
ルート集約は必ずいずれか1種類のモデルに属する。
主な仕様や制約もモデルにより大きく異なる。

以下、主要なモデルを例示する。

#### データモデル（Data Model）
データベース等の永続化媒体に永続化される情報の塊。
リレーショナルデータベースにおけるテーブルを、トランザクションの粒度（登録更新削除される粒度）ごとにまとめたものである、との理解でおおよそ十分。

#### クエリモデル（Query Model）
アプリケーションの利用者から見たデータの形。
「画面または帳票の項目定義」「外部システムインターフェース項目定義（このシステムが外部システムに渡すデータの形）」のこと。

きわめて単純なデータの場合はデータモデルとほぼ同じ形になることもあるが、ほとんどの場合、1個のクエリモデルは、1種類または複数種類のデータモデルを、利用者が欲しいデータの形に加工したものになる。

データの流れが「DB → 利用者」であるという点において、後述のコマンドモデルとは対の関係にある。

#### コマンドモデル（Command Model）
アプリケーションの利用者がこのアプリケーションに与える何らかの指示のパラメータの形。
ほとんどの場合、コマンド処理の結果、このアプリケーションが持つ何らかのデータモデルに変更が加わる。

「xxxデータ新規登録」「xxxデータ更新」など。
より具体的には「出荷指示」「売上登録」「月次報告」「申請承認」など。

データの流れが「利用者 → DB」であるという点において、前述のクエリモデルとは対の関係にある。

## 主な仕様
### スキーマ定義
- 1個のスキーマは0個以上のルート集約を持つことができる。

### ルート集約
- ルート集約には、物理名（PhysicalName）をつけなければならない。物理名には、 C#, JavaScript の識別子として用いることができる文字のみ使用できる。
- ルート集約には、表示用名称（DisplayName）をつけることができる。表示用名称には、改行、Unicode制御文字以外の全ての文字を含めることができる。
- 物理名の衝突
  - 複数のルート集約で同じ物理名を名づけることはできない。
  - この判定はモデルをまたぐ。例えば、とあるデータモデルと別のクエリモデルで同じ物理名をつけることはできない。

### 集約メンバー
- 集約メンバーには、物理名をつけなければならない。使用できる文字はルート集約の物理名に準ずる。
- 集約メンバーには、表示用名称をつけることができる。使用できる文字はルート集約の表示用名称に準ずる。
- 物理名の衝突
  - 同じ親のメンバー同士で重複する物理名をつけることはできない。
  - 異なる親のメンバー同士での重複は許可される。例えば、複数の異なるデータモデルのどちらにも「ID」という名前のメンバーを定義することはできる。

### データモデル
- ルート集約・子集約・子配列で共通の仕様
  - データモデルの集約には、1個以上の値メンバー、外部参照、子集約、子配列を持つことができる。数に上限は無い。
  - 外部参照
    - 自身のツリーの集約は参照できない。
    - データモデルの集約からはデータモデルの集約しか参照できない。
    - ルート集約だけではなく子集約や子配列を参照することもできる。
    - 循環参照について、主キーや必須制約による閉路が生じない限り、循環参照することができる。（言い方を変えると、全テーブル0件の状態からどのテーブルにもデータを投入できない状態が生じてしまう場合、循環参照できない。）
  - データモデルの集約および集約メンバーには、データベース名（DbName）をつけることができる。集約のデータベース名はRDBMSのテーブル名に、値メンバーと外部参照のデータベース名はカラム名に用いられる。
    - 複数の集約が同じ名前のテーブル名を持つことはできない。
- ルート集約
  - データモデルのルート集約が持つメンバーのうち、値メンバーと外部参照には主キー属性を付与することができる。
  - データモデルのルート集約は必ず1個以上の主キーを持たなければならない。
  - 主キーは複数定義することができる。
  - GDQM
    - データモデルのルート集約には `GenerateDefaultQueryModel` （以下GDQM）属性を付与することができる。
    - この属性が付与されたデータモデルは、本来のデータモデルのモジュールに加え、データモデルと全く同じ形のクエリモデルのモジュールも生成される。
    - GDQMデータモデルには `GenerateBatchUpdateCommand` 属性を付与することができる。この属性が付与されたものは一括更新用の Web API や、クエリモデルからデータモデルへの変換処理が作成される。
- 子集約
  - データモデルの子集約には主キー属性を付与することができない。
- 子配列
  - データモデルの子配列が持つメンバーのうち、値メンバーと外部参照には主キー属性を付与することができる。
  - データモデルの子配列は必ず1個以上の主キーを持たなければならない。
  - 主キーは複数定義することができる。

### クエリモデル
- ルート集約・子集約・子配列で共通の仕様
  - クエリモデルの集約には、1個以上の値メンバー、外部参照、子集約、子配列を持つことができる。数に上限は無い。
  - 外部参照
    - 自身のツリーの集約は参照できない。
    - クエリモデルの集約からは、クエリモデルの集約しか参照できない。
    - GDQM属性が付与されたデータモデルはクエリモデルとみなす。
    - ルート集約だけではなく子集約や子配列を参照することもできる。
    - クエリモデルで循環参照を定義することはできない。
- ルート集約
  - クエリモデルのルート集約が持つメンバーのうち、値メンバーと外部参照には主キー属性を付与することができる。この主キーは画面においてURLに現れる識別子として用いられる。
  - クエリモデルのルート集約は必ず1個以上の主キーを持たなければならない。
  - 主キーは複数定義することができる。
- 子集約
  - クエリモデルの子集約には主キー属性を付与することができない。
- 子配列
  - クエリモデルの子配列には主キー属性を付与することができない。

### コマンドモデル
- コマンドモデル1つは必ず1個の「パラメータ」と1個の「戻り値」の2個のルート集約を持つ。
- コマンドモデルの集約には、0個以上の値メンバー、外部参照、子集約、子配列を持つことができる。数に上限は無い。
- 外部参照
  - 自身のツリーの集約は参照できない。
  - コマンドモデルの集約からは、クエリモデルの集約しか参照できない。
  - GDQM属性が付与されたデータモデルはクエリモデルとみなす。
  - コマンドモデルからクエリモデルを外部参照する場合、「クエリモデルの検索条件」「クエリモデルの画面表示用データ」のどちらをパラメータないし戻り値として参照するかを選択しなければならない。
  - ルート集約だけではなく子集約や子配列を参照することもできる。
- コマンドモデルの集約には主キー属性を定義できない。

## テストパターン
以下、テスト観点ごとに必要なパターンを記述する。

メインケースでは、主要なユースケース、実務上で出現頻度の高いパターン、複雑なデータパターンを用いて、より多くの不具合を発見することを目的とする。
エッジケースでは、メインケースから漏れた観点やパターンの確認を目的とする。

### メインケース

#### 観点: データモデルの登録・更新・削除、クエリモデルの一覧検索・参照検索、コマンドモデルの基本的な挙動が正常に動作するか
NijoApplicationBuilderのメンテナンスコストを削減するため、できるだけこのテストパターンでより多くのケースをカバーする。
以下の方針でスキーマ定義する。

- スキーマ定義に用いられる用語は、機械的なものでなく、実際の業務アプリケーションに用いられるようなものを使用する。
- より複雑なパターンで正常に動作すれば、基本的にはより単純なパターンの動作も担保されるため、基本的により複雑なパターンでスキーマ定義する。具体的には以下。
  - データモデルは、GDQMであり、かつ `GenerateBatchUpdateCommand` が定義されているパターンが最も複雑
  - 主キー属性は1個だけより複数ある方がより複雑
  - 主キー属性は値メンバーより外部参照の方がより複雑
  - ChildやChildrenによる子孫集約があるとき、単一のChildやChildrenではなく、2個以上連続する方がより複雑
    - Root > Child > Child > Children > Children
    - Root > Child > Children > Child > Children
    - Root > Children > Children > Child > Child
    - Root > Children > Child > Children > Child
  - RefToによる外部参照
    - ルート集約でなく子孫集約を参照するほうがより複雑。上記の Child, Children の例との絡みで言うと、参照元・参照先、共により末端の集約である方がより複雑
    - とある集約Aから別の集約Bに対して外部参照があるとき、AからBへのRefToの経路が1個だけあるより、複数ある方がより複雑
    - 参照先の集約の親のキーに別のツリーの集約が含まれる方がより複雑
  - ツリー構造
    - 集約が自身をref-toするパターン
- データモデル
  - 基本的には、最も複雑なパターンである「GDQMかつ `GenerateBatchUpdateCommand` 」で実装する。
  - それら2属性が定義されていないデータモデルで異常が起きないかを確認するため、下記のデータモデルを少なくとも1個ずつ以上定義する。
    - GDQMでない、複雑なデータ構造をもったデータモデル
    - GDQMであるが、 `GenerateBatchUpdateCommand` ではない、複雑なデータ構造をもったデータモデル
  - 主キーに外部参照が含まれるケースは複雑な仕様が多いため、下記のパターンは重点的に確認する。
    - 主キーが外部参照1個だけから構成されるデータモデル
    - 主キーが外部参照複数個だけから構成されるデータモデル
  - 循環参照の観点は複雑すぎてこのメインケースには収まらないため、エッジケースで別途確認する。
- クエリモデル
  - GDQMのデータモデルはクエリモデルの実装を援用しているため、基本的にはGDQMのデータモデルだけで多くの不具合を拾えるが、それはそれとして純粋なクエリモデルが必要なので、下記のクエリモデルを少なくとも1個以上定義する。
    - 複雑なデータ構造をもったクエリモデル
- コマンドモデル
  - `GenerateBatchUpdateCommand` による一括更新と通常のコマンドモデルでは実装に用いているソースコードが異なるため、コマンドモデル単体での確認も必要になるので、下記のコマンドモデルを少なくとも1個以上定義する。
  - パラメータと戻り値のどちらも以下の条件を満たすコマンドモデル
    - 前述のChild, Children 2個以上連続パターンを持つ
    - 「GDQMのデータモデルの検索条件」に対する外部参照を持つ
    - 「GDQMのデータモデルの画面表示用データ」に対する外部参照を持つ
    - 「クエリモデルの検索条件」に対する外部参照を持つ
    - 「クエリモデルの画面表示用データ」に対する外部参照を持つ

### エッジケース

#### 観点: スキーマ定義のルート集約が0個の場合に異常を引き起こさないか
パターン
- ルート集約が0個のnijo.xml

#### 観点: パラメータや戻り値が存在しないコマンドモデル
パターン（1個のnijo.xmlですべて実現可能）
- パラメータの内容が空だが戻り値はメンバーあり
- パラメータはメンバーありだが戻り値は空
- パラメータ・戻り値どちらも空
