import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Layout from "../../__autoGenerated/collection"
import { ApplicationData, 属性種類定義 } from "../types"
import { ComboProps, normalize } from "../../__autoGenerated"

/** 列定義 */
export const useColumnDef = <TRow,>(createColumnDefs: (helpers: UseColumnDefArgs<TRow>) => Layout.DataTableColumn<TRow>[]) => {

  const memberType = useMemberTypeColumn()

  const columnDefs: Layout.DataTableColumn<TRow>[] = React.useMemo(() => createColumnDefs({
    text,
    specification,
    memberType,
  }), [createColumnDefs, memberType])

  return columnDefs
}

type UseColumnDefArgs<TRow> = {
  text: typeof text<TRow>
  specification: typeof specification<TRow>
  memberType: ReturnType<typeof useMemberTypeColumn>
}



/** 文字の列 */
const text = <TRow,>(props: {
  id: string
  getValue: (row: TRow) => string | undefined
  setValue: (row: TRow, value: string | undefined, rowIndex: number) => void
  header?: string
  headerGroupName?: string
  defaultWidthPx?: number
}): Layout.DataTableColumn<TRow> => ({
  id: props.id,
  header: props.header,
  headerGroupName: props.headerGroupName,
  defaultWidthPx: props.defaultWidthPx,
  onClipboardCopy: (row, rowIndex) => props.getValue(row) ?? '',
  render: (row, rowIndex) => {
    const value = props.getValue(row)
    return (
      <span>
        {value}&nbsp;
      </span>
    )
  },
  editSetting: {
    type: 'text',
    onStartEditing: row => props.getValue(row),
    onEndEditing: (row, value, rowIndex) => props.setValue(row, value, rowIndex),
    onClipboardPaste: (row, value, rowIndex) => props.setValue(row, value, rowIndex),
  },
})

/** 仕様の列 */
const specification = <TRow,>(props: {
  id: string
  getValue: (row: TRow) => 属性種類定義.Specification | undefined
  setValue: (row: TRow, value: string | undefined, rowIndex: number) => void
  header?: string
  headerGroupName?: string
  defaultWidthPx?: number
}): Layout.DataTableColumn<TRow> => ({
  id: props.id,
  header: props.header,
  headerGroupName: props.headerGroupName,
  onClipboardCopy: (row, rowIndex) => props.getValue(row) ?? '',
  render: (row, rowIndex) => {
    const value = props.getValue(row)
    return (
      <span className={value === 属性種類定義.BY_MODEL ? 'text-amber-700' : undefined}>
        {value}&nbsp;
      </span>
    )
  },
  editSetting: {
    type: 'text',
    onStartEditing: row => props.getValue(row),
    onEndEditing: (row, value, rowIndex) => props.setValue(row, value, rowIndex),
    onClipboardPaste: (row, value, rowIndex) => props.setValue(row, value, rowIndex),
  },
})

/** 属性種類コンボ列 */
const useMemberTypeColumn = () => {
  const form = ReactHookForm.useFormContext<ApplicationData>()

  const textTypes = ReactHookForm.useWatch({ name: '属性種類定義.文字系属性', control: form.control })
  const numberTypes = ReactHookForm.useWatch({ name: '属性種類定義.数値系属性', control: form.control })
  const timeTypes = ReactHookForm.useWatch({ name: '属性種類定義.時間系属性', control: form.control })
  const typeTypes = ReactHookForm.useWatch({ name: '属性種類定義.区分系属性', control: form.control })
  const otherTypes = ReactHookForm.useWatch({ name: '属性種類定義.その他の属性', control: form.control })

  return React.useCallback(<TRow,>(props: {
    id: string
    getValue: (row: TRow) => string | undefined
    setValue: (row: TRow, value: string | undefined, rowIndex: number) => void
    header?: string
    headerGroupName?: string
    defaultWidthPx?: number
  }): Layout.DataTableColumn<TRow> => {

    const typeLists = [...textTypes, ...numberTypes, ...timeTypes, ...typeTypes, ...otherTypes]
    type ComboItem = typeof typeLists[number]

    const comboProps: ComboProps<ComboItem, string | undefined> = {
      onFilter: keyword => {
        if (keyword) {
          const normalized = normalize(keyword)
          const filtered = typeLists.filter(x => x.型名 && normalize(x.型名).includes(normalized))
          return Promise.resolve(filtered)
        } else {
          return Promise.resolve(typeLists)
        }
      },
      getOptionText: opt => opt.型名,
      getValueFromOption: opt => opt.uniqueId,
      getValueText: val => {
        return val
          ? (typeLists.find(x => x.uniqueId === val)?.型名 ?? '')
          : ''
      },
    }

    const editSetting: Layout.ColumnEditSetting<TRow, ComboItem> = {
      type: 'combo',
      comboProps: comboProps as unknown as ComboProps<ComboItem, ComboItem>,
      onStartEditing: row => props.getValue(row) as unknown as ComboItem,
      onEndEditing: (row, value, rowIndex) => props.setValue(row, value as string | undefined, rowIndex),
      onClipboardPaste: (row, value, rowIndex) => props.setValue(row, value, rowIndex),
    }

    return {
      id: props.id,
      header: props.header,
      headerGroupName: props.headerGroupName,
      onClipboardCopy: (row, rowIndex) => props.getValue(row) ?? '',
      render: (row, rowIndex) => {
        const typeUniqueId = props.getValue(row)
        const typeDef = typeLists.find(x => x.uniqueId === typeUniqueId)
        return (
          <span>
            {typeDef?.型名 ?? typeUniqueId}&nbsp;
          </span>
        )
      },
      editSetting: editSetting as Layout.ColumnEditSetting<TRow, unknown>,
    }
  }, [textTypes, numberTypes, timeTypes, typeTypes, otherTypes])
}
