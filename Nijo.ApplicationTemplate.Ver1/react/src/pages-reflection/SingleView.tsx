import * as React from "react"
import * as ReactRouter from "react-router-dom"
import * as ReactHookForm from "react-hook-form"
import * as AutoGenerated from "../__autoGenerated"
import * as Layout from "../layout"
import * as Input from "../input"
import * as Util from "../util"
import { MetadataForPage } from "../__autoGenerated/util"
import { MetadataSchema } from "./getSchema"
import { ReflectionForm } from "./Parts.Form"

/** QueryModel1件の詳細を閲覧・編集する画面 */
export const SingleView = <
  TQueryModelType extends AutoGenerated.QueryModelType
>({ rootAggregatePhysicalName, metadata, schema }: {
  rootAggregatePhysicalName: TQueryModelType
  metadata: MetadataForPage.StructureMetadata
  schema: MetadataSchema
}) => {

  type TDisplayData = AutoGenerated.DisplayData.TypeMap[TQueryModelType]

  // 画面表示時、URLから主キーを取得。
  // 主キーでサーバーに検索をかけ、データを読み込む。
  const urlParams = ReactRouter.useParams()
  const { complexPost } = Util.useHttpRequest()
  const [nowLoading, setNowLoading] = React.useState(false)
  const [defaultValues, setDefaultValues] = React.useState<ReactHookForm.DefaultValues<TDisplayData>>()
  const [errorMessage, setErrorMessage] = React.useState<string>()

  React.useEffect(() => {
    // URLから主キーを取得
    const keyNames = schema.getSingleViewUrlKeyNames(metadata)
    const keys = keyNames.map(keyName => urlParams[keyName])

    // 主キーでサーバーに検索をかけ、データを読み込む。
    loadSingle(keys)

  }, [])

  const loadSingle = React.useCallback(async (keys: unknown[]) => {
    setNowLoading(true)
    setErrorMessage(undefined)
    setDefaultValues(undefined)
    try {
      // キーを検索条件オブジェクトに設定
      const searchCondition = AutoGenerated.SearchCondition.create[rootAggregatePhysicalName]()
      AutoGenerated.SearchCondition.assignKeys[rootAggregatePhysicalName](searchCondition, keys)
      searchCondition.take = 2 // キーで絞るので1件しかとれないはずではあるが念のため

      // 検索実行
      const endpoint = AutoGenerated.LoadFeature.Endpoint[rootAggregatePhysicalName]
      const response = await complexPost<AutoGenerated.LoadFeature.ReturnType[TQueryModelType]>(endpoint, searchCondition, {
        ignoreConfirm: true,
      })

      // 0件または2件以上の場合はエラー
      if (!response || response.currentPageItems.length === 0) {
        setErrorMessage("データが見つかりません")
      } else if (response.currentPageItems.length >= 2) {
        setErrorMessage("データが複数見つかりました")
      } else {
        setDefaultValues(response.currentPageItems[0] as ReactHookForm.DefaultValues<TDisplayData>)
      }
    } catch (error) {
      setErrorMessage("データの読み込みに失敗しました")
    } finally {
      setNowLoading(false)
    }
  }, [complexPost, rootAggregatePhysicalName])

  return (
    <Layout.PageFrame
      headerContent={(
        <Layout.PageFrameTitle>
          {metadata.displayName}
        </Layout.PageFrameTitle>
      )}
      className="p-4 relative"
    >
      {nowLoading && (
        <Layout.NowLoading />
      )}
      {errorMessage && (
        <span className="text-rose-500">{errorMessage}</span>
      )}
      {defaultValues && (
        <AfterLoaded
          rootAggregatePhysicalName={rootAggregatePhysicalName}
          defaultValues={defaultValues}
          metadata={metadata}
          schema={schema}
        />
      )}
    </Layout.PageFrame>
  )
}

const AfterLoaded = <
  TQueryModelType extends AutoGenerated.QueryModelType
>({ rootAggregatePhysicalName, metadata, schema, defaultValues }: {
  rootAggregatePhysicalName: TQueryModelType
  metadata: MetadataForPage.StructureMetadata
  schema: MetadataSchema
  defaultValues: ReactHookForm.DefaultValues<AutoGenerated.DisplayData.TypeMap[TQueryModelType]>
}) => {

  // フォーム
  const form = ReactHookForm.useForm({
    defaultValues,
  })

  console.log("AfterLoaded", defaultValues)

  return (
    <ReflectionForm
      mode="single-view"
      metadataPhysicalName={rootAggregatePhysicalName}
      metadata={metadata}
      schema={schema}
      formMethods={form as unknown as ReactHookForm.UseFormReturn<ReactHookForm.FieldValues>}
    />
  )
}