import * as React from "react"
import useEvent from "react-use-event-hook"
import * as ReactHookForm from "react-hook-form"
import * as Layout from "../layout"
import * as Input from "../input"
import * as AutoGenerated from "../__autoGenerated"
import { MetadataForPage } from "../__autoGenerated/util/metadata-for-page"
import { getValueByPath } from "../layout/EditableGrid/EditableGrid.utils"
import { MetadataSchema } from "./getSchema"
import { ReflectionFormContext } from "./Parts.FormContext"

export const ReflectionGridInSingleView = ({ ownerPhysicalName, owner, ancestorsPath, className }: {
  /** 祖先のパス。XML上の物理名をピリオドで繋いだもの */
  ancestorsPath: string
  /** 配列のオーナー（つまりChildrenAggregate）の物理名 */
  ownerPhysicalName: string
  /** 配列のオーナー（つまりChildrenAggregate）のメタデータ */
  owner: MetadataForPage.StructureMetadata
  className?: string
}) => {
  const { rootAggregate, schema, formMethods: { control } } = React.useContext(ReflectionFormContext)

  const arrayPath = ancestorsPath ? `${ancestorsPath}.${ownerPhysicalName}` : ownerPhysicalName
  const { fields, update, append, remove } = ReactHookForm.useFieldArray({ control, name: arrayPath })
  const getColumnDefs = useReflectionGridColumnDefs(owner, schema)
  const gridRef = React.useRef<Layout.EditableGridRef<ReactHookForm.FieldValues>>(null)

  const handleAdd = useEvent(() => {
    const displayDataPath = `${rootAggregate}.${arrayPath}`.replace('.', '/') as AutoGenerated.QueryModelTypeAll
    console.log(displayDataPath)
    const newInstance = AutoGenerated.DisplayData.create[displayDataPath]()
    append(newInstance)
  })
  const handleRemove = useEvent(() => {
    const selected = gridRef.current?.getSelectedRows().map(x => x.rowIndex)
    if (selected) remove(selected)
  })
  const handleChangeRow: Layout.RowChangeEvent<ReactHookForm.FieldValues> = useEvent(e => {
    for (const item of e.changedRows) {
      update(item.rowIndex, item.newRow)
    }
  })

  return (
    <div className="flex flex-col gap-px">
      <div className="flex gap-1">
        <Input.IconButton outline mini onClick={handleAdd}>追加</Input.IconButton>
        <Input.IconButton outline mini onClick={handleRemove}>削除</Input.IconButton>
      </div>
      <Layout.EditableGrid
        ref={gridRef}
        rows={fields}
        getColumnDefs={getColumnDefs}
        onChangeRow={handleChangeRow}
        className={className}
      />
    </div>
  )
}

/**
 * 構造体のメタデータを受け取って EditableGrid を構築して返すコンポーネント
 */
export const useReflectionGridColumnDefs = (
  /** 構造体のメタデータ */
  metadata: MetadataForPage.StructureMetadata,
  /** メタデータのスキーマ */
  schema: MetadataSchema,
) => {
  const getColumnDefs: Layout.GetColumnDefsFunction<ReactHookForm.FieldValues> = React.useCallback(cellType => {
    const columns = collectGridColumns(metadata)
    return columns.map(({ memberPhysicalName, memberMetadata }) => toGridColumnDef(memberPhysicalName, memberMetadata, cellType))
  }, [metadata])

  return getColumnDefs
}

/**
 * 自身のメンバーと、子孫のうちChildAggregateのメンバーを集める。
 * ChildrenAggregateは除外
 */
const collectGridColumns = (metadata: MetadataForPage.StructureMetadata): { memberPhysicalName: string, memberMetadata: MetadataForPage.StructureMetadataMember }[] => {
  const result: { memberPhysicalName: string, memberMetadata: MetadataForPage.StructureMetadataMember }[] = []
  for (const [memberPhysicalName, memberMetadata] of Object.entries(metadata.members)) {
    if (memberMetadata.type === "ChildrenAggregate") {
      // ChildrenAggregateのメンバーはグリッドで表現できないので除外

    } else if (memberMetadata.type === "ChildAggregate") {
      result.push(...collectGridColumns(memberMetadata))

    } else {
      result.push({ memberPhysicalName, memberMetadata })
    }
  }
  return result
}

/**
 * メンバーのメタデータを受け取って GridColumnDef を構築して返す
 */
const toGridColumnDef = <
  TRow extends ReactHookForm.FieldValues
>(
  memberPhysicalName: string,
  member: MetadataForPage.StructureMetadataMember,
  cellType: Layout.ColumnDefFactories<TRow>
): Layout.EditableGridColumnDef<TRow> => {

  const fieldPath = `values.${memberPhysicalName}`

  if (member.type === "word" || member.type === "description") {
    return cellType.text(fieldPath as ReactHookForm.FieldPathByValue<TRow, string | undefined>, member.displayName)
  }

  if (member.type === "int" || member.type === "decimal" || member.type === "year" || member.type === "yearmonth") {
    return cellType.number(fieldPath as ReactHookForm.FieldPathByValue<TRow, number | undefined>, member.displayName)
  }

  if (member.type === "date" || member.type === "datetime") {
    return cellType.date(fieldPath as ReactHookForm.FieldPathByValue<TRow, string | undefined>, member.displayName)
  }

  if (member.type === "bool") {
    return cellType.boolean(fieldPath as ReactHookForm.FieldPathByValue<TRow, boolean>, member.displayName)
  }

  return cellType.other(member.displayName)
}

/** 外部参照の列定義を作成する。 */
const toGridColumnDefForRefTo = <
  TRow extends ReactHookForm.FieldValues
>(
  memberPhysicalName: string,
  member: MetadataForPage.RefMetadata,
  cellType: Layout.ColumnDefFactories<TRow>
) => {
  return cellType.other(member.displayName, {
    renderCell: (row) => {
      const refToObject = getValueByPath(row, `values.${memberPhysicalName}`)
      return (
        <div>
          TODO
        </div>
      )
    }
  })
}
