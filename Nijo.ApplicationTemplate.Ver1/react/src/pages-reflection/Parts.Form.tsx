import * as React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Layout from "../layout"
import * as Input from "../input"
import * as AutoGenerated from "../__autoGenerated"
import * as EnumDefs from "../__autoGenerated/enum-defs"
import { MetadataForPage } from "../__autoGenerated/util/metadata-for-page"
import { MetadataSchema } from "./getSchema"
import { ReflectionFormContext } from "./Parts.FormContext"
import { ReflectionGridInSingleView } from "./Parts.Grid"
/**
 * 構造体のメタデータを受け取って VForm のルートを構築して返すコンポーネント
 */
export const ReflectionForm = ({ mode, metadataPhysicalName, metadata, schema, formMethods }: {
  mode: ReflectionFormContext["mode"]
  metadataPhysicalName: string
  metadata: MetadataForPage.StructureMetadata
  schema: MetadataSchema
  formMethods: ReactHookForm.UseFormReturn<ReactHookForm.FieldValues>
}) => {
  const formContextValue = React.useMemo<ReflectionFormContext>(() => ({
    rootAggregate: metadataPhysicalName as AutoGenerated.QueryModelType,
    mode,
    schema,
    formMethods,
  }), [mode, schema, formMethods, metadataPhysicalName])

  return (
    <ReflectionFormContext.Provider value={formContextValue}>
      <Layout.VForm2.Root estimatedLabelWidth="10rem">
        <MemberComponentsGroupedByBreakPoint owner={metadata} ancestorsPath="" />
      </Layout.VForm2.Root>
    </ReflectionFormContext.Provider>
  )
}

/** VForm2のラベルと値の組を折り返しの単位でグルーピングしたもの */
const MemberComponentsGroupedByBreakPoint = ({ owner, ancestorsPath }: {
  ancestorsPath: string
  owner: MetadataForPage.StructureMetadata
}) => {

  // メンバーを折り返しの単位でグルーピングする
  const groups = React.useMemo(() => {
    const members = Object.entries(owner.members).map(([key, member]) => ({ physicalName: key, member }))
    return members.reduce((acc, member) => {
      // Child, Children は横幅いっぱいとる
      if (member.member.type === "ChildAggregate" || member.member.type === "ChildrenAggregate") {
        acc.push({ members: [{ physicalName: member.physicalName, member: member.member }], fullWidth: true })
        return acc
      }

      // それ以外はグルーピングする
      const lastGroup = acc[acc.length - 1]
      if (lastGroup === undefined) {
        acc.push({ members: [{ physicalName: member.physicalName, member: member.member }], fullWidth: false })
      } else {
        lastGroup.members.push({ physicalName: member.physicalName, member: member.member })
      }
      return acc
    }, [] as { members: { physicalName: string, member: MetadataForPage.StructureMetadataMember }[], fullWidth: boolean }[])
  }, [owner])

  return (
    <>
      {groups.map(({ members, fullWidth }, index) => fullWidth ? (
        <MemberComponent
          key={index}
          ancestorsPath={ancestorsPath}
          memberName={members[0].physicalName}
          member={members[0].member}
        />
      ) : (
        <Layout.VForm2.AutoColumn key={index} childrenCount={members.length}>
          {members.map((member) => (
            <MemberComponent
              key={member.physicalName}
              ancestorsPath={ancestorsPath}
              memberName={member.physicalName}
              member={member.member}
            />
          ))}
        </Layout.VForm2.AutoColumn>
      ))}
    </>
  )
}

/** VForm2のラベルと値の組 */
const MemberComponent = ({ memberName, member, ancestorsPath }: {
  /** 祖先のパス */
  ancestorsPath: string
  /** メンバーの物理名 */
  memberName: string
  /** メンバー */
  member: MetadataForPage.StructureMetadataMember
}): React.ReactNode => {

  const {
    mode,
    schema,
    formMethods: { control },
  } = React.useContext(ReflectionFormContext)

  // Root
  if (member.type === "RootAggregate") {
    return undefined // Rootはトップで処理済み。この分岐には来ない
  }

  // Child
  if (member.type === "ChildAggregate") {
    return (
      <Layout.VForm2.Indent label={member.displayName}>
        <MemberComponentsGroupedByBreakPoint
          ancestorsPath={ancestorsPath ? `${ancestorsPath}.${memberName}` : memberName}
          owner={member}
        />
      </Layout.VForm2.Indent>
    )
  }

  // Children
  if (member.type === "ChildrenAggregate") {
    // このメンバーの子孫（直下の子ではなく子孫再帰的に）にさらにChildrenが含まれるならばフォームのリスト。
    // 子孫にChildrenがいないならばグリッドで表示する。
    let hasChildren = false
    const checkRecursive = (childMembers: MetadataForPage.StructureMetadataMember[]) => {
      for (const childMember of childMembers) {
        if (childMember.type === "ChildrenAggregate") {
          hasChildren = true
          return
        }
        if (childMember.type === "ChildAggregate") {
          checkRecursive(Object.values(childMember.members))
        }
      }
    }
    checkRecursive(Object.values(member.members))

    // 子孫にChildrenがいるならばフォームのリスト
    if (hasChildren || mode === "search-condition") {
      return (
        <Layout.VForm2.Indent label={member.displayName}>
          <MemberComponentsGroupedByBreakPoint
            ancestorsPath={ancestorsPath ? `${ancestorsPath}.${memberName}` : memberName}
            owner={member}
          />
        </Layout.VForm2.Indent>
      )
    }

    // 子孫にChildrenがいないのでグリッドで表示する
    return (
      <Layout.VForm2.Item wideLabelValue label={member.displayName}>
        <ReflectionGridInSingleView
          ancestorsPath={ancestorsPath}
          ownerPhysicalName={memberName}
          owner={member}
          className="border border-gray-300"
        />
      </Layout.VForm2.Item>
    )
  }

  // 外部参照
  if (member.type === "ref-to") {
    return (
      <Layout.VForm2.Item label={member.displayName} required={member.required && mode === "single-view"}>
        TODO
      </Layout.VForm2.Item>
    )
  }

  // SingleViewの場合、DisplayDataの値メンバーはvaluesという名前のオブジェクトの中にある
  const valuesMemberPath = mode === "single-view"
    ? `${ancestorsPath}.values.${memberName}`
    : `${ancestorsPath}.${memberName}`

  // 一般ValueMember
  if (member.type !== undefined) {

    // 単語
    if (member.type === "word") {
      return (
        <Layout.VForm2.Item label={member.displayName} required={member.required && mode === "single-view"}>
          <Input.Word
            control={control}
            name={valuesMemberPath}
          />
        </Layout.VForm2.Item>
      )
    }

    // 文章
    if (member.type === "description") {
      return mode === "single-view" ? (
        <Layout.VForm2.Item label={member.displayName} required={member.required}>
          <Input.Description
            control={control}
            name={valuesMemberPath}
          />
        </Layout.VForm2.Item>
      ) : (
        // 部分一致検索なので、入力欄はWord型と同じ
        <Layout.VForm2.Item label={member.displayName}>
          <Input.Word
            control={control}
            name={valuesMemberPath}
          />
        </Layout.VForm2.Item>
      )
    }

    // 数値
    if (member.type === "int" || member.type === "decimal") {
      return mode === "single-view" ? (
        <Layout.VForm2.Item label={member.displayName} required={member.required}>
          <Input.NumberInput
            control={control}
            name={valuesMemberPath}
          />
        </Layout.VForm2.Item>
      ) : (
        // 範囲検索
        <Layout.VForm2.Item label={member.displayName}>
          <div className="flex flex-wrap items-center gap-1">
            <Input.NumberInput
              control={control}
              name={`${valuesMemberPath}.from`}
              className="max-w-24"
            />
            ～
            <Input.NumberInput
              control={control}
              name={`${valuesMemberPath}.to`}
              className="max-w-24"
            />
          </div>
        </Layout.VForm2.Item>
      )
    }

    // 日付、日付時刻
    if (member.type === "date" || member.type === "datetime") {
      return mode === "single-view" ? (
        <Layout.VForm2.Item label={member.displayName} required={member.required}>
          <Input.DateInput
            control={control}
            name={valuesMemberPath}
          />
        </Layout.VForm2.Item>
      ) : (
        // 範囲検索
        <Layout.VForm2.Item label={member.displayName}>
          <div className="flex flex-wrap items-center gap-1">
            <Input.DateInput
              control={control}
              name={`${valuesMemberPath}.from`}
              className="max-w-40"
            />
            ～
            <Input.DateInput
              control={control}
              name={`${valuesMemberPath}.to`}
              className="max-w-40"
            />
          </div>
        </Layout.VForm2.Item>
      )
    }

    // チェックボックス
    if (member.type === "bool") {
      return mode === "single-view" ? (
        <Layout.VForm2.Item label={member.displayName} required={member.required}>
          <Input.CheckBox
            control={control}
            name={valuesMemberPath}
          />
        </Layout.VForm2.Item>
      ) : (
        // 検索条件
        <Layout.VForm2.Item label={member.displayName}>
          <div className="flex flex-wrap gap-x-2 gap-y-1">
            <Input.CheckBox
              control={control}
              name={`${valuesMemberPath}.trueのみ`}
            >
              Trueのみ
            </Input.CheckBox>
            <Input.CheckBox
              control={control}
              name={`${valuesMemberPath}.falseのみ`}
            >
              Falseのみ
            </Input.CheckBox>
          </div>
        </Layout.VForm2.Item>
      )
    }

    return (
      <Layout.VForm2.Item label={member.displayName}>
        TODO
      </Layout.VForm2.Item>
    )
  }

  // 列挙型
  if (member.enumType !== undefined) {
    const enumValues = EnumDefs.EnumValueMap[member.enumType]()

    return mode === "single-view" ? (
      <Layout.VForm2.Item label={member.displayName} required={member.required} >
        <Input.EnumSelect
          type={member.enumType}
          control={control}
          name={valuesMemberPath}
        />
      </Layout.VForm2.Item>
    ) : (
      // 検索条件
      <Layout.VForm2.Item label={member.displayName}>
        <div className="flex flex-wrap gap-x-2 gap-y-1">
          {enumValues.map((value) => (
            <Input.CheckBox
              key={value}
              control={control}
              name={`${valuesMemberPath}.${value}`}
            >
              {value}
            </Input.CheckBox>
          ))}
        </div>
      </Layout.VForm2.Item>
    )
  }

  // 値オブジェクト（UIは単語型のそれに倣う）
  if (member.valueObjectType !== undefined) {
    return (
      <Layout.VForm2.Item label={member.displayName} required={member.required && mode === "single-view"}>
        <Input.Word
          control={control}
          name={valuesMemberPath}
        />
      </Layout.VForm2.Item>
    )
  }
}
