import * as React from "react"
import * as ReactRouter from "react-router-dom"
import * as ReactHookForm from "react-hook-form"
import * as Layout from "../layout"
import * as Input from "../input"
import * as Util from "../util"
import * as AutoGenerated from "../__autoGenerated"
import { MetadataForPage } from "../__autoGenerated/util"
import useEvent from "react-use-event-hook"
import { Panel, PanelGroup, PanelResizeHandle } from "react-resizable-panels"
import { ReflectionForm } from "./Parts.Form"
import { useReflectionGridColumnDefs } from "./Parts.Grid"
import { MetadataSchema } from "./getSchema"
import { UUID } from "uuidjs"

/** QueryModelの一覧検索画面 */
export const MultiView = ({ rootAggregatePhysicalName, metadata, schema }: {
  rootAggregatePhysicalName: string
  metadata: MetadataForPage.StructureMetadata
  schema: MetadataSchema
}) => {

  const queryModelType = rootAggregatePhysicalName as AutoGenerated.QueryModelType

  // 画面上部で編集中の検索条件
  type TSearchCondition = AutoGenerated.SearchCondition.TypeMap[typeof queryModelType]
  const form = ReactHookForm.useForm<TSearchCondition>()

  // 最後に検索を実行したときの検索結果
  type TDisplayData = AutoGenerated.DisplayData.TypeMap[typeof queryModelType]
  const [currentPageItems, setCurrentPageItems] = React.useState<TDisplayData[]>([])
  const [totalCount, setTotalCount] = React.useState<number>()
  const getMemberColumnDefs = useReflectionGridColumnDefs(metadata, schema)
  const getColumnDefs: Layout.GetColumnDefsFunction<ReactHookForm.FieldValues> = React.useCallback(cellType => {

    // 詳細画面へのリンクの列
    const linkColumn: Layout.EditableGridColumnDef<ReactHookForm.FieldValues> = cellType.other('', {
      renderCell: cell => {
        const keys = AutoGenerated.DisplayData.extractKeys[queryModelType](cell.row.original as any)
        const link = `/${rootAggregatePhysicalName}/detail/${keys.map(key => (key as object)?.toString()).join('/')}`
        return (
          <ReactRouter.Link to={link}>
            詳細
          </ReactRouter.Link>
        )
      }
    })

    return [
      linkColumn,
      ...getMemberColumnDefs(cellType),
    ]
  }, [getMemberColumnDefs])

  // 短時間に何度も検索が試行されたときに最後の処理のみ有効にするためのref
  const latestSearchIdRef = React.useRef<string>(undefined)

  // 検索処理。
  // 検索ボタン押下やページングなどのタイミングで検索条件がURLのクエリパラメータに反映され、
  // 検索処理はformの値ではなくURLの値を使用する。
  const navigate = ReactRouter.useNavigate()
  const { pathname, search, state } = ReactRouter.useLocation()
  const { complexPost } = Util.useHttpRequest()
  const [isLoaded, setIsLoaded] = React.useState(false)

  const executeSearch = useEvent(async (searchCondition: TSearchCondition) => {
    // この画面に遷移したうえで、クエリパラメータに検索条件をシリアライズして付加する。
    // TODO Ver1: SearchConditionとURLクエリパラメータを相互に変換する処理を自動生成する必要あり
    navigate(`${pathname}?${new URLSearchParams().toString()}`, {
      // useEffectを発火させるため検索トリガーの値を更新
      state: { [SEARCH_TRIGGER]: UUID.generate() }
    })
  })

  React.useEffect(() => {
    setIsLoaded(false)

    const searchId = UUID.generate()
    latestSearchIdRef.current = searchId

    // URLのクエリパラメータから検索条件を取得し、検索条件オブジェクトにアサインする
    const searchCondition = AutoGenerated.SearchCondition.create[queryModelType]()
    // TODO Ver1: SearchConditionとURLクエリパラメータを相互に変換する処理を自動生成する必要あり
    // console.log(AutoGenerated.LoadFeature.Endpoint[queryModelType])
    complexPost<AutoGenerated.LoadFeature.ReturnType[typeof queryModelType]>(
      AutoGenerated.LoadFeature.Endpoint[queryModelType],
      searchCondition
    ).then(response => {
      // 検索開始後に別の検索が開始されていたら処理中断
      if (latestSearchIdRef.current !== searchId) return;
      if (response) {
        setCurrentPageItems(response.currentPageItems)
        setTotalCount(response.totalCount)
      } else {
        setCurrentPageItems([])
        setTotalCount(undefined)
      }
      setIsLoaded(true)
    })
  }, [latestSearchIdRef, pathname, search, state?.[SEARCH_TRIGGER]])

  // 新規登録画面へ遷移する
  const handleNavigateNew = useEvent(() => {
    navigate(`/${rootAggregatePhysicalName}/new`)
  })

  return (
    <Layout.PageFrame
      headerContent={(
        <>
          <Layout.PageFrameTitle>
            {metadata.displayName}
          </Layout.PageFrameTitle>
          <div className="flex-1"></div>
          {!metadata.isReadOnly && (
            <Input.IconButton onClick={handleNavigateNew}>新規</Input.IconButton>
          )}
        </>
      )}
    >
      <PanelGroup direction="vertical">
        <Panel collapsible minSize={8}>
          <form onSubmit={form.handleSubmit(executeSearch)} className="h-full overflow-y-auto p-4">
            <Layout.VForm2.LabelText>検索条件</Layout.VForm2.LabelText>
            <ReflectionForm
              mode="search-condition"
              metadataPhysicalName={rootAggregatePhysicalName}
              metadata={metadata}
              schema={schema}
              formMethods={form as unknown as ReactHookForm.UseFormReturn<ReactHookForm.FieldValues>}
            />
          </form>
        </Panel>

        <PanelResizeHandle className="h-1 bg-gray-300" />

        <Panel className="relative">
          {!isLoaded && (
            <Layout.NowLoading />
          )}
          {isLoaded && (
            <Layout.EditableGrid
              rows={currentPageItems}
              getColumnDefs={getColumnDefs}
              className="h-full"
            />
          )}
        </Panel>
      </PanelGroup>
    </Layout.PageFrame>
  )
}

/**
 * ページングや再検索の場合、クエリパラメータは一切変更されないが、
 * それでも検索処理が実行されてほしいため、
 * useLocationのstateにユニークな値を設定して、
 * その値が変更されたタイミングで検索処理を実行する。
 */
const SEARCH_TRIGGER = "::SEARCH_TRIGGER_UUID::"
