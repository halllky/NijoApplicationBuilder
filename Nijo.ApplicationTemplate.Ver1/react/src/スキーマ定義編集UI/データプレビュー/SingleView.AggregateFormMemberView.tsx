import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { EditableDbRecord, DbTableSingleItemEditor, ReloadTrigger, TableMetadataHelper } from "./types"
import useQueryEditorServerApi from "./useQueryEditorServerApi"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useEvent from "react-use-event-hook"
import { useEditorDesign } from "./useEditorDesign"
import { DbRecordSelectorDialog, DbRecordSelectorDialogProps } from "./DbRecordSelectorDialog"
import { SingleViewContext } from "./SingleView"
import { AggregateFormView } from "./SingleView.AggregateFormView"
import { AggregateGridView } from "./SingleView.AggregateGridView"

/**
 * 集約のメンバー1個分を編集するコンポーネント
 */
export const AggregateMemberFormView = ({ record, onChangeRecord, member, owner, ownerName, ownerIsReadOnly }: {
  record: EditableDbRecord | undefined,
  onChangeRecord: (value: EditableDbRecord) => void,
  member: DataModelMetadata.AggregateMember | DataModelMetadata.Aggregate
  owner: DataModelMetadata.Aggregate
  ownerName: string
  ownerIsReadOnly: boolean
}) => {

  const {
    formMethods,
    tableMetadataHelper,
  } = React.useContext(SingleViewContext)

  const { savedDesign } = useEditorDesign()
  const { getDbRecords } = useQueryEditorServerApi()

  // ラベル列の横幅
  const labelCssProperties: React.CSSProperties = React.useMemo(() => {
    const rootPath = tableMetadataHelper.getRoot(owner).path
    const labelWidth = savedDesign[rootPath]?.singleViewLabelWidth ?? '10em'
    return { flexBasis: labelWidth, minWidth: labelWidth }
  }, [savedDesign, owner, tableMetadataHelper])

  // 読み取り専用判定
  const isReadOnly = React.useMemo(() => {
    // 親が読み取り専用の場合は、子も読み取り専用
    if (ownerIsReadOnly) return true

    // 表示されないので未定義
    if (member.type === "root") return undefined
    if (member.type === "child") return undefined
    if (member.type === "children") return undefined
    if (member.type === "parent-key") return undefined
    if (member.type === "own-column") return member.isPrimaryKey && record?.existsInDb
    if (member.type === "ref-key") return member.isPrimaryKey && record?.existsInDb
  }, [member, record?.existsInDb, ownerIsReadOnly])

  // テキストボックスの値変更時
  const handleChangeText: React.ChangeEventHandler<HTMLInputElement> = useEvent(e => {
    if (!record) return;
    if (member.type !== "own-column" && member.type !== "ref-key") return;
    const clone = window.structuredClone(record)
    clone.values[member.columnName] = e.target.value === '' ? null : e.target.value
    onChangeRecord(clone)
  })

  // 参照キーの検索
  const [refKeySearchDialogProps, setRefKeySearchDialogProps] = React.useState<DbRecordSelectorDialogProps | null>(null)
  const handleSearch = useEvent(() => {
    if (member.type !== "ref-key") return;
    const refToTableMetadata = tableMetadataHelper.getRefTo(member)
    if (!refToTableMetadata) return;
    setRefKeySearchDialogProps({
      tableMetadata: refToTableMetadata,
      tableMetadataHelper: tableMetadataHelper,
      onSelect: keys => {
        if (!record) return;

        // 参照先テーブルが複合キーである可能性を考慮し、当該参照先の全キーに代入
        const clone = window.structuredClone(record)
        let index = 0
        for (const m of owner.members) {
          if (m.type !== "ref-key" || m.refToRelationName !== member.refToRelationName) continue;
          const value = keys[index] as string
          clone.values[m.columnName] = value === '' ? null : value
          index++
        }
        onChangeRecord(clone)
        setRefKeySearchDialogProps(null)
      },
      onCancel: () => {
        setRefKeySearchDialogProps(null)
      },
    })
  })

  // ルート集約はAggregateViewで処理する。ここには来ない
  if (member.type === "root") {
    throw new Error("ルート集約はAggregateViewで処理する")
  }

  // 親の主キー（非表示）
  if (member.type === "parent-key") {
    return undefined
  }

  // テーブル自身の属性のカラム、または外部参照のキー項目
  if (member.type === "own-column" || member.type === "ref-key") {
    return (
      <>
        <div className="flex gap-1 items-center">
          <div
            className="text-sm break-all select-none text-gray-600"
            style={labelCssProperties}
          >
            {member.columnName}
          </div>
          <div className={`flex-1 flex border ${isReadOnly ? 'border-transparent' : 'bg-white border-gray-500'}`}>
            {member.type === "ref-key" && !isReadOnly && (
              <Input.IconButton icon={Icon.MagnifyingGlassIcon} hideText mini onClick={handleSearch}>
                検索
              </Input.IconButton>
            )}
            <input
              type="text"
              value={record?.values[member.columnName] ?? ''}
              onChange={handleChangeText}
              spellCheck={false}
              placeholder="NULL"
              className="flex-1 px-1 outline-none placeholder:text-gray-300"
              readOnly={isReadOnly}
            />
          </div>
          {refKeySearchDialogProps && (
            <DbRecordSelectorDialog {...refKeySearchDialogProps} />
          )}
        </div>

        {/* 参照先テーブルの主キー以外の属性 */}
        {member.type === "ref-key" && (
          <div className="flex gap-1 items-center">
            <div style={labelCssProperties}></div>
            <RefKeyAdditionalColumns
              member={member}
              record={record}
              owner={owner}
              tableMetadataHelper={tableMetadataHelper}
              savedDesign={savedDesign}
              getDbRecords={getDbRecords}
            />
          </div>
        )}
      </>
    )
  }

  if (member.type === "child") {
    const childAggregate = tableMetadataHelper.allAggregates().find(a => a.tableName === member.tableName)
    if (!childAggregate) {
      throw new Error("子集約が見つかりません")
    }
    return (
      <AggregateFormView
        itemIndexInDbRecordArray={0}
        aggregate={childAggregate}
        owner={record ?? null}
        ownerIsReadOnly={ownerIsReadOnly}
        onChangeDefinition={undefined}
      />
    )
  }

  if (member.type === "children") {
    return (
      <AggregateGridView
        itemIndexInForm={0}
        owner={record ?? null}
        ownerMetadata={owner}
        childrenMetadata={member}
        ownerName={ownerName}
        ownerIsReadOnly={ownerIsReadOnly}
      />
    )
  }

  return (
    <div>
      未実装: {member.type}
    </div>
  )
}

/**
 * ref-key の参照先テーブルの追加カラムを表示するコンポーネント
 */
const RefKeyAdditionalColumns = ({
  member,
  record,
  owner,
  tableMetadataHelper,
  savedDesign,
  getDbRecords
}: {
  member: DataModelMetadata.AggregateMember
  record: EditableDbRecord | undefined
  owner: DataModelMetadata.Aggregate
  tableMetadataHelper: TableMetadataHelper
  savedDesign: ReturnType<typeof useEditorDesign>['savedDesign']
  getDbRecords: ReturnType<typeof useQueryEditorServerApi>['getDbRecords']
}) => {
  const [refData, setRefData] = React.useState<EditableDbRecord | null>(null)
  const [isLoading, setIsLoading] = React.useState(false)

  // 設定から refDisplayColumnNames を取得
  const rootPath = tableMetadataHelper.getRoot(owner).path
  const refDisplayColumnNames = React.useMemo(() => {
    if (!member.refToRelationName) return []
    return savedDesign[rootPath]?.membersDesign?.[member.refToRelationName]?.singleViewRefDisplayColumnNames || []
  }, [savedDesign, rootPath, member.refToRelationName])

  // 参照先テーブルの情報を取得
  const refToAggregate = React.useMemo(() => {
    if (!member.refToAggregatePath) return null
    return tableMetadataHelper.allAggregates().find(a => a.path === member.refToAggregatePath)
  }, [member.refToAggregatePath, tableMetadataHelper])

  // 参照先テーブルのキー値が変更されたタイミングでデータを取得
  const refKeyValue = record?.values[member.columnName]
  const { trigger } = React.useContext(SingleViewContext)
  React.useEffect(() => {

    if (!refKeyValue || !refToAggregate || refDisplayColumnNames.length === 0) {
      setRefData(null)
      return
    }

    setIsLoading(true)

    // 参照先テーブルから該当レコードを取得
    const primaryKeyColumns = refToAggregate.members
      .filter((m): m is DataModelMetadata.AggregateMember =>
        m.type === 'own-column' && m.isPrimaryKey
      )
      .map(m => m.columnName)

    if (primaryKeyColumns.length === 0) return

    const whereClause = `${primaryKeyColumns[0]} = '${refKeyValue.replace(/'/g, "''")}'`

    getDbRecords({
      tableName: refToAggregate.tableName,
      whereClause,
    }).then(res => {
      if (res.ok && res.data.records.length > 0) {
        setRefData(res.data.records[0])
      } else {
        setRefData(null)
      }
    }).finally(() => {
      setIsLoading(false)
    })

  }, [refKeyValue, refToAggregate, refDisplayColumnNames, getDbRecords, trigger])

  // 表示するカラムがない場合は何も表示しない
  if (!refDisplayColumnNames.length || !refToAggregate) {
    return null
  }

  return (
    <div className="flex-1 pt-px pb-2 flex gap-px flex-wrap">
      {refDisplayColumnNames.map(columnName => (
        <div key={columnName} className="flex gap-x-2 flex-wrap items-center">
          <span className="text-xs text-gray-500">{columnName}:</span>
          <span className="select-text text-gray-800">
            {isLoading ? '…' : refData?.values[columnName]}
            &nbsp;
          </span>
        </div>
      ))}
    </div>
  )
}
