import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { EditableDbRecord, DbTableSingleItemEditor, ReloadTrigger, TableMetadataHelper } from "./types"
import useQueryEditorServerApi from "./useQueryEditorServerApi"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useEvent from "react-use-event-hook"
import { DbTableEditorViewRef } from "./MultiView"
import { UUID } from "uuidjs"
import { RecordStatusText } from "./RecordStatusText"
import { DataPreviewGlobalContext } from "./DataPreviewGlobalContext"
import { EditorDesignByAgggregate } from "./types"
import { DbTableSingleEditViewSettings, DbTableSingleEditViewSettingsProps, SingleViewSettingFormData } from "./SingleView.Settings"
import { AggregateFormView } from "./SingleView.AggregateFormView"


export type SingleViewProps = {
  itemIndex: number
  value: DbTableSingleItemEditor
  onChangeDefinition: (index: number, value: DbTableSingleItemEditor) => void
  onDeleteDefinition: (index: number) => void
  onIsDirtyChange: (index: number, isDirty: boolean) => void
  tableMetadataHelper: TableMetadataHelper
  trigger: ReloadTrigger
  zoom: number
  handleMouseDown: React.MouseEventHandler<Element>
}

/** SingleViewのuseFormで管理するデータの型 */
export type SingleViewFormType = {
  [tablePath: string]: EditableDbRecord[]
}

/** SingleViewのウィンドウ1個の中で横断的に参照されるコンテキスト */
export type SingleViewContextType = {
  rootItemKeys: string[] | null
  tableMetadataHelper: TableMetadataHelper | undefined
  /** この画面で新規作成され、まだDBに登録されていないデータの親子関係を管理するマップ。キーが子、値が親 */
  newItemsParentMap: Map<string, string>
  setNewItemsParentMap: React.Dispatch<React.SetStateAction<Map<string, string>>>
  trigger: ReloadTrigger
}

/** SingleViewのウィンドウ1個の中で横断的に参照されるコンテキスト */
export const SingleViewContext = React.createContext<SingleViewContextType>({
  rootItemKeys: null,
  tableMetadataHelper: undefined,
  newItemsParentMap: new Map(),
  setNewItemsParentMap: () => { },
  trigger: 1,
})

/**
 * DBレコードを集約単位で1件分編集するウィンドウ
 */
export const SingleView = React.forwardRef((props: SingleViewProps, ref: React.ForwardedRef<DbTableEditorViewRef>) => {

  const {
    itemIndex,
    value: propsValue,
    onChangeDefinition,
    onDeleteDefinition,
    onIsDirtyChange,
    tableMetadataHelper,
    trigger,
    zoom,
    handleMouseDown,
  } = props
  const [error, setError] = React.useState<string | null>(null)
  const { getDbRecords } = useQueryEditorServerApi()
  const [defaultValues, setDefaultValues] = React.useState<SingleViewFormType>({})
  const [rootAggregate, setRootAggregate] = React.useState<DataModelMetadata.Aggregate | null>(null)
  const [rootRecord, setRootRecord] = React.useState<EditableDbRecord | null>(null)
  const [triggerOnlyThisWindow, setTriggerOnlyThisWindow] = React.useState(-1)
  const bodyRef = React.useRef<HTMLDivElement>(null)
  const [settingsDialogProps, setSettingsDialogProps] = React.useState<DbTableSingleEditViewSettingsProps | null>(null)
  const { getValues: getDataPreviewValues, setValue: setDataPreviewValues } = React.useContext(DataPreviewGlobalContext)

  React.useEffect(() => {
    (async () => {
      setError(null)

      const rootAggregate = tableMetadataHelper.rootAggregates().find(a => a.tableName === propsValue.rootTableName)
      if (!rootAggregate) {
        setError("ルート集約が見つかりません")
        return
      }
      setRootAggregate(rootAggregate)

      // defaultValuesの作成
      const result: SingleViewFormType = {}
      const tree = [rootAggregate, ...tableMetadataHelper.enumerateDescendants(rootAggregate)]
      if (propsValue.rootItemKeys === null) {
        // 新規作成モードの場合
        for (const aggregate of tree) {
          if (aggregate.type === "root") {
            result[aggregate.path] = [{
              uniqueId: UUID.generate(),
              tableName: aggregate.tableName,
              values: {},
              existsInDb: false,
              changed: false,
              deleted: false,
            }]
          } else {
            result[aggregate.path] = []
          }
        }
      } else {
        // 編集モードの場合、
        // 対象のテーブルおよびその子孫テーブルそれぞれについて
        // ルート集約のテーブルの主キーで検索をかける。
        for (const aggregate of tree) {
          const primaryKeyColumnNames = aggregate.members
            .filter(c => (c.type === "own-column" || c.type === "parent-key" || c.type === "ref-key" || c.type === "ref-parent-key") && c.isPrimaryKey)
            .map(c => (c as DataModelMetadata.AggregateMember).columnName)
          const whereClause = propsValue.rootItemKeys.map((pk, index) => `${primaryKeyColumnNames[index]} = '${pk.replace(/'/g, "''")}'`).join(" AND ")
          const res = await getDbRecords({
            tableName: aggregate.tableName,
            whereClause,
          })
          if (res.ok) {
            // ルート集約が見つからなかったら終わり
            if (aggregate.path === rootAggregate.path && res.data.records.length === 0) {
              setError(`対象レコードが見つかりません（${propsValue.rootItemKeys.join(", ")}）`)
              return
            }
            result[aggregate.path] = res.data.records
          } else {
            setError(res.error ?? "不明なエラーが発生しました")
          }
        }
      }
      setDefaultValues(result)

    })()
  }, [trigger, triggerOnlyThisWindow])

  const handleCloseWindow = useEvent(() => {
    onDeleteDefinition(itemIndex)
  })

  const rootRecordAccessorRef = React.useRef<RootRecordAccessorRef | null>(null)
  const handleDeleteTreeRecords = useEvent(() => {
    rootRecordAccessorRef.current?.updateRootRecord(prev => ({ ...prev, deleted: true }))
  })

  const handleClickReset = useEvent(() => {
    if (!window.confirm('データの変更を取り消しますか？')) return
    rootRecordAccessorRef.current?.resetForm()
    setError(null)
  })

  const handleReload = useEvent(() => {
    setTriggerOnlyThisWindow(prev => prev * -1)
  })

  const handleOpenSettings = useEvent(() => {
    if (!rootAggregate) return

    // 集約ツリー全部の設定値を設定画面の初期値として取得
    const initialSettings: SingleViewSettingFormData = {}
    const tree = [rootAggregate, ...tableMetadataHelper.enumerateDescendants(rootAggregate)]
    for (const aggregate of tree) {
      initialSettings[aggregate.path] = getDataPreviewValues(`design.${aggregate.path}`) ?? {}
    }

    setSettingsDialogProps({
      rootAggregate: rootAggregate,
      tableMetadataHelper,
      initialSettings,
      onApply: (updatedSettings) => {
        // 集約ツリー全部の設定値をsetValueする
        for (const aggregate of tree) {
          setDataPreviewValues(`design.${aggregate.path}`, updatedSettings[aggregate.path], { shouldDirty: true })
        }
        setSettingsDialogProps(null)
      },
      onCancel: () => {
        setSettingsDialogProps(null)
      },
    })
  })

  return (
    <div className="bg-gray-200 border-2 border-white h-full flex flex-col">
      {/* ヘッダ */}
      <div className="flex items-center gap-1 p-1 bg-gray-200 cursor-grab">
        <span onMouseDown={handleMouseDown} className="truncate select-none text-gray-500 font-bold">
          {rootAggregate?.displayName}
        </span>
        <RecordStatusText record={rootRecord} className="text-sm" />
        <div className="flex-1 self-stretch" onMouseDown={handleMouseDown}></div>

        {propsValue.rootItemKeys !== null && defaultValues && (<>
          {!rootRecord?.deleted && (
            <Input.IconButton icon={Icon.TrashIcon} mini onClick={handleDeleteTreeRecords}>
              削除
            </Input.IconButton>
          )}
          <Input.IconButton icon={Icon.ArrowUturnLeftIcon} mini onClick={handleClickReset}>
            リセット
          </Input.IconButton>
        </>)}
        <Input.IconButton icon={Icon.Cog6ToothIcon} mini hideText onClick={handleOpenSettings}>
          設定
        </Input.IconButton>
        <Input.IconButton icon={Icon.XMarkIcon} hideText onClick={handleCloseWindow}>
          ウィンドウを閉じる
        </Input.IconButton>
      </div>

      {/* ボディ */}
      <div ref={bodyRef} className="flex-1 overflow-scroll relative bg-gray-200">
        {error && (
          <div className="flex flex-col items-start gap-1 p-1">
            <div className="text-rose-500">{error}</div>
            <Input.IconButton icon={Icon.ArrowUturnLeftIcon} outline onClick={handleReload}>
              再読み込み
            </Input.IconButton>
          </div>
        )}
        {!error && rootAggregate && (
          <SingleViewAfterLoaded
            {...props}
            ref={ref}
            rootAggregate={rootAggregate}
            rootRecordAccessorRef={rootRecordAccessorRef}
            defaultValues={defaultValues}
            onRootRecordChange={setRootRecord}
          />
        )}
      </div>

      {settingsDialogProps && (
        <DbTableSingleEditViewSettings {...settingsDialogProps} />
      )}
    </div>
  )
})

// ----------------------------------
type RootRecordAccessorRef = {
  /** 現在表示中のデータが読み込まれた当時の状態にリセットする */
  resetForm: () => void
  /** 親コンポーネントから子コンポーネントが持つルート集約のレコードを更新する */
  updateRootRecord: (dispatch: (prev: EditableDbRecord) => EditableDbRecord) => void
}

const SingleViewAfterLoaded = React.forwardRef((props: SingleViewProps & {
  rootAggregate: DataModelMetadata.Aggregate
  rootRecordAccessorRef: React.RefObject<RootRecordAccessorRef | null>
  defaultValues: SingleViewFormType
  onRootRecordChange: (record: EditableDbRecord) => void
}, ref: React.ForwardedRef<DbTableEditorViewRef>) => {
  const {
    itemIndex,
    value,
    onChangeDefinition,
    onDeleteDefinition,
    onIsDirtyChange,
    tableMetadataHelper,
    handleMouseDown,
    rootAggregate,
    rootRecordAccessorRef,
    defaultValues,
    onRootRecordChange,
    trigger,
  } = props

  const formMethods = ReactHookForm.useForm<SingleViewFormType>({
    defaultValues,
  })
  const { control, reset, formState: { isDirty }, getValues } = formMethods
  React.useEffect(() => {
    reset(defaultValues)
  }, [defaultValues])

  React.useEffect(() => {
    onIsDirtyChange(itemIndex, isDirty)
  }, [isDirty])

  const [newItemsParentMap, setNewItemsParentMap] = React.useState<Map<string, string>>(new Map())
  const singleViewContext: SingleViewContextType = React.useMemo(() => ({
    rootItemKeys: value.rootItemKeys,
    tableMetadataHelper,
    newItemsParentMap,
    setNewItemsParentMap,
    trigger,
  }), [value.rootItemKeys, tableMetadataHelper, newItemsParentMap, setNewItemsParentMap, trigger])

  const handleChangeDefinition = useEvent((dispatch: (prev: DbTableSingleItemEditor) => DbTableSingleItemEditor) => {
    onChangeDefinition(itemIndex, dispatch(value))
  })

  React.useImperativeHandle(ref, () => ({
    getCurrentRecords: () => {
      const result: EditableDbRecord[] = []
      const currentValues = getValues()
      for (const record of Object.values(currentValues).flatMap(r => r)) {

        // 親の主キーを設定
        const childTableInfo = tableMetadataHelper.allAggregates().find(a => a.tableName === record.tableName)
        const parentTableInfo = childTableInfo ? tableMetadataHelper.getParent(childTableInfo) : undefined
        const parentUniqueId = newItemsParentMap.get(record.uniqueId)
        if (childTableInfo && parentTableInfo && parentUniqueId) {
          const parent = currentValues[parentTableInfo.path].find(r => r.uniqueId === parentUniqueId)
          let index = 0
          for (const member of childTableInfo.members ?? []) {
            if (member.type !== "parent-key") continue
            const parentColumn = parentTableInfo.members[index] as DataModelMetadata.AggregateMember
            record.values[member.columnName] = parent?.values[parentColumn.columnName] ?? null
            index++
          }
        }
        result.push(record)
      }
      return result
    },
    getCurrentRootItemKeys: () => {
      const rootRecord = getValues()[rootAggregate.path][0]
      const keys: string[] = []
      for (const member of rootAggregate.members) {
        if (member.type !== "own-column" && member.type !== "ref-key" && member.type !== "parent-key" && member.type !== "ref-parent-key") continue
        if (!member.isPrimaryKey) continue
        const value = rootRecord.values[member.columnName]
        keys.push(value ?? '')
      }
      return keys
    },
  }))

  // 親コンポーネントにルートレコードへのアクセサを提供する
  const { update } = ReactHookForm.useFieldArray({ name: rootAggregate.path, control })
  const rootRecord = ReactHookForm.useWatch({ name: `${rootAggregate.path}.0`, control })
  React.useImperativeHandle(rootRecordAccessorRef, () => ({
    resetForm: () => {
      reset(defaultValues)
    },
    updateRootRecord: (dispatch: (prev: EditableDbRecord) => EditableDbRecord) => {
      update(0, dispatch(rootRecord))
    },
  }), [rootRecord, update, reset])

  React.useEffect(() => {
    onRootRecordChange(rootRecord)
  }, [rootRecord])

  return (
    <SingleViewContext.Provider value={singleViewContext}>
      <ReactHookForm.FormProvider {...formMethods}>
        <AggregateFormView
          itemIndexInDbRecordArray={0} // ルート集約は1つしかないので0
          aggregate={rootAggregate}
          owner={null}
          ownerIsReadOnly={rootRecord?.deleted === true}
          onChangeDefinition={handleChangeDefinition}
        />
      </ReactHookForm.FormProvider>
    </SingleViewContext.Provider>
  )
})
