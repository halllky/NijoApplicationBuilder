import React from "react"
import { EditableDbRecord } from "../types"
import { DataModelMetadata } from "../../../__autoGenerated/util"
import useQueryEditorServerApi from "../useQueryEditorServerApi"

/**
 * 外部キーを使って参照先テーブルのレコードを検索するカスタムフック
 */
export const useForeignKeyLookup = ({
  record,
  foreignKeyRelationName,
  ownerTableMetadata,
  refToAggregate,
  getDbRecords,
  trigger,
}: {
  record: EditableDbRecord | undefined
  foreignKeyRelationName: string
  ownerTableMetadata: DataModelMetadata.Aggregate
  refToAggregate: DataModelMetadata.Aggregate | null
  getDbRecords: ReturnType<typeof useQueryEditorServerApi>['getDbRecords']
  trigger?: unknown // 再検索トリガー
}) => {
  const [data, setData] = React.useState<EditableDbRecord | null>(null)
  const [isLoading, setIsLoading] = React.useState(false)
  const [error, setError] = React.useState<string | null>(null)

  React.useEffect(() => {
    if (!record || !refToAggregate) {
      setData(null)
      setError(null)
      return
    }

    // 外部キーの値を取得
    const foreignKeyMembers = ownerTableMetadata.members.filter(
      (m): m is DataModelMetadata.AggregateMember =>
        (m.type === "ref-key" || m.type === "ref-parent-key") &&
        (m as DataModelMetadata.AggregateMember).refToRelationName === foreignKeyRelationName
    )

    // 外部キーの値がすべて存在するかチェック
    const hasAllForeignKeyValues = foreignKeyMembers.every(m => {
      const value = record.values[m.columnName]
      return value !== null && value !== undefined && value !== ''
    })

    if (!hasAllForeignKeyValues) {
      setData(null)
      setError(null)
      return
    }

    setIsLoading(true)
    setError(null)

    const fetchData = async () => {
      try {
        // 複合キーに対応した検索条件を作成
        const whereClause = foreignKeyMembers
          .map(m => ({ mine: m.columnName!, their: m.refToColumnName! }))
          .map(({ mine, their }) => {
            const value = record.values[mine] ?? ''
            return `${their} = '${value.replace(/'/g, "''")}'`
          })
          .join(" AND ")

        if (!whereClause) {
          setError('検索条件が作成できません')
          return
        }

        const result = await getDbRecords({
          tableName: refToAggregate.tableName,
          whereClause,
        })

        if (result.ok && result.data.records.length > 0) {
          setData(result.data.records[0])
        } else {
          setData(null)
        }
      } catch (err) {
        setError('取得エラー')
      } finally {
        setIsLoading(false)
      }
    }

    fetchData()
  }, [record, foreignKeyRelationName, ownerTableMetadata, refToAggregate, getDbRecords, trigger])

  return {
    data,
    isLoading,
    error,
  }
}
