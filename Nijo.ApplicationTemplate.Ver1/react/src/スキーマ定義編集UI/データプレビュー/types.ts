import { DataModelMetadata } from "../../__autoGenerated/util"
import { DiagramItem } from "../../layout/DiagramView"

/** クエリエディタのデータ構造 */
export type QueryEditor = {
  id: string
  title: string
  items: QueryEditorItem[]
  comments: Comment[]
}

/** クエリエディタのアイテム */
export type QueryEditorItem = SqlAndResult | DbTableMultiItemEditor | DbTableSingleItemEditor

/** すべてのダイアグラムアイテム（クエリ、テーブル編集、コメント） */
export type QueryEditorDiagramItem = SqlAndResult | DbTableMultiItemEditor | DbTableSingleItemEditor | (Comment & { type: "comment" })

/** SQLとその結果を表示するアイテム */
export type SqlAndResult = DiagramItem & {
  title: string
  type: "sqlAndResult"
  sql: string
  isSettingCollapsed: boolean
}

/** データベースのテーブルを一括編集するアイテム */
export type DbTableMultiItemEditor = DiagramItem & {
  title: string
  type: "dbTableEditor"
  tableName: string
  whereClause: string
  isSettingCollapsed: boolean
}

/** データベースのテーブルを集約単位で1件分編集するアイテム */
export type DbTableSingleItemEditor = DiagramItem & {
  title: string
  type: "dbTableSingleEditor"
  rootTableName: string
  /** nullの場合は新規作成モード */
  rootItemKeys: string[] | null
  isSettingCollapsed: boolean
}

/** 各クエリやテーブル編集がサーバーからの再読み込みをトリガーするためのトークン */
export type ReloadTrigger = unknown

// ------------------------------------
/** コメント */
export type Comment = DiagramItem & {
  content: string
}

// ------------------------------------
export type UseQueryEditorServerApiReturn = {
  /** クエリを実行する */
  executeQuery: (sql: string) => Promise<{ ok: true, records: ExecuteQueryReturn } | { ok: false, error: string }>
  /** テーブルメタデータ取得 */
  getTableMetadata: () => Promise<{ ok: true, data: TableMetadataHelper } | { ok: false, error: string }>
  /** 更新用レコード取得 */
  getDbRecords: (query: GetDbRecordsParameter) => Promise<{ ok: true, data: GetDbRecordsReturn } | { ok: false, error: string }>
  /** レコード一括更新 */
  batchUpdate: (records: EditableDbRecord[]) => Promise<{ ok: true } | { ok: false, error: string }>

  /** データベース初期化オプション取得 */
  getDummyDataGenerateOptions: () => Promise<{ ok: true, data: { [key: string]: boolean } } | { ok: false, error: string }>
  /** データベース初期化 */
  destroyAndResetDatabase: (options: { [key: string]: boolean }) => Promise<{ ok: true } | { ok: false, error: string }>
}

export type GetDbRecordsParameter = {
  tableName: string
  whereClause: string
}

export type ExecuteQueryReturn = {
  columns: string[]
  rows: Record<string, string | null>[]
}

export type GetDbRecordsReturn = {
  records: EditableDbRecord[]
}

export type EditableDbRecord = {
  uniqueId: string
  tableName: string
  values: Record<string, string | null>
  existsInDb: boolean
  changed: boolean
  deleted: boolean
}

// ------------------------------------
export type TableMetadataHelper = ReturnType<typeof tableMetadataHelper>

export const tableMetadataHelper = (rootAggregates: DataModelMetadata.Aggregate[]) => {

  /** すべての集約の一覧を返す */
  const allAggregates = () => {
    const result: DataModelMetadata.Aggregate[] = []
    const pushRecursively = (aggregate: DataModelMetadata.Aggregate) => {
      result.push(aggregate)
      for (const member of aggregate.members) {
        if (member.type === "child" || member.type === "children") {
          pushRecursively(member)
        }
      }
    }
    for (const aggregate of rootAggregates) {
      pushRecursively(aggregate)
    }
    return result
  }

  /** ルート集約を探して返す */
  const getRoot = (aggregate: DataModelMetadata.Aggregate) => {
    // パスの先頭がルート集約の物理名
    const rootPath = aggregate.path.split("/")[0]
    const rootAggregate = rootAggregates.find(m => m.physicalName === rootPath)
    if (!rootAggregate) {
      throw new Error(`ルート集約が見つかりません: ${rootPath}`)
    }
    return rootAggregate
  }

  /** 対象の集約の親集約を探して返す */
  const getParent = (aggregate: DataModelMetadata.Aggregate) => {
    const parentPath = aggregate.path.split("/").slice(0, -1).join("/")
    const parentAggregate = allAggregates().find(m => m.path === parentPath)
    return parentAggregate
  }

  /** 対象の集約の子孫集約を列挙する */
  const enumerateDescendants = (aggregate: DataModelMetadata.Aggregate) => {
    const result: DataModelMetadata.Aggregate[] = []
    const pushRecursively = (agg: DataModelMetadata.Aggregate) => {
      for (const member of agg.members) {
        if (member.type === "child" || member.type === "children") {
          result.push(member)
          pushRecursively(member)
        }
      }
    }
    pushRecursively(aggregate)
    return result
  }

  /** 外部参照先テーブルを探して返す */
  const getRefTo = (column: DataModelMetadata.AggregateMember) => {
    if (column.type !== "ref-key") {
      return undefined
    }
    return allAggregates().find(m => m.path === column.refToAggregatePath)
  }

  return {
    /** ルート集約の一覧を返す */
    rootAggregates: () => [...rootAggregates],
    /** すべての集約の一覧を返す */
    allAggregates,
    /** ルート集約を探して返す */
    getRoot,
    /** 対象の集約の親集約を探して返す */
    getParent,
    /** 対象の集約の子孫集約を列挙する */
    enumerateDescendants,
    /** 外部参照先テーブルを探して返す */
    getRefTo,
  }
}
