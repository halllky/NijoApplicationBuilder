import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { EditableDbRecord, DbTableSingleItemEditor, ReloadTrigger, TableMetadataHelper } from "./types"
import useQueryEditorServerApi from "./useQueryEditorServerApi"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useEvent from "react-use-event-hook"
import { DbTableEditorViewRef } from "./DbTableMultiEditorView"
import { useDbRecordGridColumnDef } from "./useDbRecordGridColumnDef"
import { UUID } from "uuidjs"
import { RecordStatusText } from "./RecordStatusText"
import { useEditorDesign } from "./useEditorDesign"

export type DbTableSingleItemSelectorDialogProps = {
  tableMetadata: DataModelMetadata.Aggregate
  tableMetadataHelper: TableMetadataHelper
  onSelect: (keys: string[]) => void
  onCancel: () => void
  children?: React.ReactNode
}

/**
 * どのコードを編集するかを選択するダイアログ
 */
export const DbTableSingleItemSelectorDialog = ({
  tableMetadata,
  tableMetadataHelper,
  onSelect,
  onCancel,
  children,
}: DbTableSingleItemSelectorDialogProps) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [records, setRecords] = React.useState<EditableDbRecord[]>()
  const [error, setError] = React.useState<string | null>(null)

  React.useEffect(() => {
    (async () => {
      const res = await getDbRecords({
        tableName: tableMetadata.tableName,
        whereClause: "",
      })
      if (res.ok) {
        setRecords(res.data.records)
      } else {
        setError(res.error)
      }
    })()
  }, [])

  const columnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    // 選択
    const selectColumn = cellType.other('', {
      defaultWidth: 60,
      isFixed: true,
      renderCell: cell => {

        const handleClick = () => {
          const primaryKeyColumns = tableMetadata.members
            .filter(c => (c.type === "own-column" || c.type === "parent-key" || c.type === "ref-key") && c.isPrimaryKey)
            .map(c => (c as DataModelMetadata.AggregateMember).columnName)
          const primaryKeyValues = primaryKeyColumns.map(c => cell.row.original.values[c] ?? '')
          onSelect(primaryKeyValues)
        }

        return (
          <Input.IconButton underline mini onClick={handleClick}>
            選択
          </Input.IconButton>
        )
      },
    })

    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []
    for (const column of tableMetadata.members) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは別のウィンドウ
        continue
      } else if (column.type === "own-column" || column.type === "parent-key" || column.type === "ref-key") {
        valueColumns.push(cellType.text(
          `values.${column.columnName}` as ReactHookForm.FieldPathByValue<EditableDbRecord, string | undefined>,
          column.columnName ?? '',
          {}))
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      selectColumn,
      ...valueColumns,
    ]
  }, [tableMetadata])

  return (
    <Layout.ModalDialog
      open
      className="relative w-[80vw] h-[80vh] bg-white flex flex-col gap-1 relative border border-gray-400"
    >
      <div className="h-full w-full flex flex-col p-1 gap-1">

        <div className="flex gap-1 p-1">
          <span className="font-bold">
            編集対象データを選択してください。
          </span>
          <div className="flex-1"></div>
          {children}
          <Input.IconButton outline mini onClick={onCancel}>
            キャンセル
          </Input.IconButton>
        </div>

        {error && (
          <div className="text-red-500 flex-1">
            {error}
          </div>
        )}
        {records && (
          <Layout.EditableGrid
            rows={records}
            getColumnDefs={columnDefs}
            className="flex-1"
          />
        )}
      </div>

      {!error && !records && (
        <Layout.NowLoading />
      )}
    </Layout.ModalDialog>
  )
}

// ------------------------------------

type DbTableSingleEditViewProps = {
  itemIndex: number
  value: DbTableSingleItemEditor
  onChangeDefinition: (index: number, value: DbTableSingleItemEditor) => void
  onDeleteDefinition: (index: number) => void
  onIsDirtyChange: (index: number, isDirty: boolean) => void
  tableMetadataHelper: TableMetadataHelper
  trigger: ReloadTrigger
  zoom: number
  handleMouseDown: React.MouseEventHandler<Element>
}

/** SingleViewのuseFormで管理するデータの型 */
type SingleViewFormType = {
  [tablePath: string]: EditableDbRecord[]
}

type SingleViewContextType = {
  rootItemKeys: string[] | null
  formMethods: ReactHookForm.UseFormReturn<SingleViewFormType>
  tableMetadataHelper: TableMetadataHelper
  /** この画面で新規作成され、まだDBに登録されていないデータの親子関係を管理するマップ。キーが子、値が親 */
  newItemsParentMap: Map<string, string>
  setNewItemsParentMap: React.Dispatch<React.SetStateAction<Map<string, string>>>
}
const SingleViewContext = React.createContext<SingleViewContextType>({
  rootItemKeys: null,
  formMethods: {} as ReactHookForm.UseFormReturn<SingleViewFormType>,
  tableMetadataHelper: {} as TableMetadataHelper,
  newItemsParentMap: new Map(),
  setNewItemsParentMap: () => { },
})

/**
 * DBレコードを集約単位で1件分編集するウィンドウ
 */
export const DbTableSingleEditView = React.forwardRef((props: DbTableSingleEditViewProps, ref: React.ForwardedRef<DbTableEditorViewRef>) => {

  const {
    itemIndex,
    value: propsValue,
    onChangeDefinition,
    onDeleteDefinition,
    onIsDirtyChange,
    tableMetadataHelper,
    trigger,
    zoom,
    handleMouseDown,
  } = props
  const [error, setError] = React.useState<string | null>(null)
  const { getDbRecords } = useQueryEditorServerApi()
  const [defaultValues, setDefaultValues] = React.useState<SingleViewFormType>({})
  const [rootAggregate, setRootAggregate] = React.useState<DataModelMetadata.Aggregate | null>(null)
  const [rootRecord, setRootRecord] = React.useState<EditableDbRecord | null>(null)
  const [triggerOnlyThisWindow, setTriggerOnlyThisWindow] = React.useState(-1)
  const bodyRef = React.useRef<HTMLDivElement>(null)

  React.useEffect(() => {
    (async () => {
      setError(null)

      const rootAggregate = tableMetadataHelper.rootAggregates().find(a => a.tableName === propsValue.rootTableName)
      if (!rootAggregate) {
        setError("ルート集約が見つかりません")
        return
      }
      setRootAggregate(rootAggregate)

      // defaultValuesの作成
      const result: SingleViewFormType = {}
      const tree = [rootAggregate, ...tableMetadataHelper.enumerateDescendants(rootAggregate)]
      if (propsValue.rootItemKeys === null) {
        // 新規作成モードの場合
        for (const aggregate of tree) {
          if (aggregate.type === "root") {
            result[aggregate.path] = [{
              uniqueId: UUID.generate(),
              tableName: aggregate.tableName,
              values: {},
              existsInDb: false,
              changed: false,
              deleted: false,
            }]
          } else {
            result[aggregate.path] = []
          }
        }
      } else {
        // 編集モードの場合、
        // 対象のテーブルおよびその子孫テーブルそれぞれについて
        // ルート集約のテーブルの主キーで検索をかける。
        for (const aggregate of tree) {
          const primaryKeyColumnNames = aggregate.members
            .filter(c => (c.type === "own-column" || c.type === "parent-key" || c.type === "ref-key") && c.isPrimaryKey)
            .map(c => (c as DataModelMetadata.AggregateMember).columnName)
          const whereClause = propsValue.rootItemKeys.map((pk, index) => `${primaryKeyColumnNames[index]} = '${pk.replace(/'/g, "''")}'`).join(" AND ")
          const res = await getDbRecords({
            tableName: aggregate.tableName,
            whereClause,
          })
          if (res.ok) {
            // ルート集約が見つからなかったら終わり
            if (aggregate.path === rootAggregate.path && res.data.records.length === 0) {
              setError(`対象レコードが見つかりません（${propsValue.rootItemKeys.join(", ")}）`)
              return
            }
            result[aggregate.path] = res.data.records
          } else {
            setError(res.error ?? "不明なエラーが発生しました")
          }
        }
      }
      setDefaultValues(result)

    })()
  }, [trigger, triggerOnlyThisWindow])

  const handleCloseWindow = useEvent(() => {
    onDeleteDefinition(itemIndex)
  })

  const rootRecordAccessorRef = React.useRef<RootRecordAccessorRef | null>(null)
  const handleDeleteTreeRecords = useEvent(() => {
    rootRecordAccessorRef.current?.updateRootRecord(prev => ({ ...prev, deleted: true }))
  })

  const handleClickReset = useEvent(() => {
    if (!window.confirm('データの変更を取り消しますか？')) return
    rootRecordAccessorRef.current?.resetForm()
    setError(null)
  })

  const handleReload = useEvent(() => {
    setTriggerOnlyThisWindow(prev => prev * -1)
  })

  return (
    <div className="bg-gray-200 border border-gray-300 h-full flex flex-col">
      {/* ヘッダ */}
      <div className="flex items-center gap-1 p-1 bg-gray-100 border-b border-gray-300 cursor-grab">
        <span onMouseDown={handleMouseDown} className="truncate select-none">
          {rootAggregate?.displayName}
        </span>
        <RecordStatusText record={rootRecord} className="text-sm" />
        <div className="flex-1 self-stretch" onMouseDown={handleMouseDown}></div>

        {propsValue.rootItemKeys !== null && defaultValues && (<>
          {!rootRecord?.deleted && (
            <Input.IconButton icon={Icon.TrashIcon} mini onClick={handleDeleteTreeRecords}>
              削除
            </Input.IconButton>
          )}
          <Input.IconButton icon={Icon.ArrowUturnLeftIcon} mini onClick={handleClickReset}>
            リセット
          </Input.IconButton>
        </>)}
        <Input.IconButton icon={Icon.XMarkIcon} hideText onClick={handleCloseWindow}>
          ウィンドウを閉じる
        </Input.IconButton>
      </div>

      {/* ボディ */}
      <div ref={bodyRef} className="flex-1 overflow-scroll relative bg-gray-200">
        {error && (
          <div className="flex flex-col items-start gap-1 p-1">
            <div className="text-rose-500">{error}</div>
            <Input.IconButton icon={Icon.ArrowUturnLeftIcon} outline onClick={handleReload}>
              再読み込み
            </Input.IconButton>
          </div>
        )}
        {!error && rootAggregate && (
          <DbTableSingleEditViewAfterLoaded
            {...props}
            ref={ref}
            rootAggregate={rootAggregate}
            rootRecordAccessorRef={rootRecordAccessorRef}
            defaultValues={defaultValues}
            onRootRecordChange={setRootRecord}
          />
        )}
      </div>
    </div>
  )
})

// ----------------------------------
type RootRecordAccessorRef = {
  /** 現在表示中のデータが読み込まれた当時の状態にリセットする */
  resetForm: () => void
  /** 親コンポーネントから子コンポーネントが持つルート集約のレコードを更新する */
  updateRootRecord: (dispatch: (prev: EditableDbRecord) => EditableDbRecord) => void
}

const DbTableSingleEditViewAfterLoaded = React.forwardRef((props: DbTableSingleEditViewProps & {
  rootAggregate: DataModelMetadata.Aggregate
  rootRecordAccessorRef: React.RefObject<RootRecordAccessorRef | null>
  defaultValues: SingleViewFormType
  onRootRecordChange: (record: EditableDbRecord) => void
}, ref: React.ForwardedRef<DbTableEditorViewRef>) => {
  const {
    itemIndex,
    value,
    onChangeDefinition,
    onDeleteDefinition,
    onIsDirtyChange,
    tableMetadataHelper,
    handleMouseDown,
    rootAggregate,
    rootRecordAccessorRef,
    defaultValues,
    onRootRecordChange,
  } = props

  const formMethods = ReactHookForm.useForm<SingleViewFormType>({
    defaultValues,
  })
  React.useEffect(() => {
    formMethods.reset(defaultValues)
  }, [defaultValues])

  React.useEffect(() => {
    onIsDirtyChange(itemIndex, formMethods.formState.isDirty)
  }, [formMethods.formState.isDirty])

  const [newItemsParentMap, setNewItemsParentMap] = React.useState<Map<string, string>>(new Map())
  const singleViewContext: SingleViewContextType = React.useMemo(() => ({
    rootItemKeys: value.rootItemKeys,
    formMethods,
    tableMetadataHelper,
    newItemsParentMap,
    setNewItemsParentMap,
  }), [value.rootItemKeys, formMethods, tableMetadataHelper, newItemsParentMap, setNewItemsParentMap])

  const handleChangeDefinition = useEvent((dispatch: (prev: DbTableSingleItemEditor) => DbTableSingleItemEditor) => {
    onChangeDefinition(itemIndex, dispatch(value))
  })

  React.useImperativeHandle(ref, () => ({
    getCurrentRecords: () => {
      const result: EditableDbRecord[] = []
      const currentValues = formMethods.getValues()
      for (const record of Object.values(currentValues).flatMap(r => r)) {

        // 親の主キーを設定
        const childTableInfo = tableMetadataHelper.allAggregates().find(a => a.tableName === record.tableName)
        const parentTableInfo = childTableInfo ? tableMetadataHelper.getParent(childTableInfo) : undefined
        const parentUniqueId = newItemsParentMap.get(record.uniqueId)
        if (childTableInfo && parentTableInfo && parentUniqueId) {
          const parent = currentValues[parentTableInfo.path].find(r => r.uniqueId === parentUniqueId)
          let index = 0
          for (const member of childTableInfo.members ?? []) {
            if (member.type !== "parent-key") continue
            const parentColumn = parentTableInfo.members[index] as DataModelMetadata.AggregateMember
            record.values[member.columnName] = parent?.values[parentColumn.columnName] ?? null
            index++
          }
        }
        result.push(record)
      }
      return result
    },
    getCurrentRootItemKeys: () => {
      const rootRecord = formMethods.getValues()[rootAggregate.path][0]
      const keys: string[] = []
      for (const member of rootAggregate.members) {
        if (member.type !== "own-column" && member.type !== "ref-key" && member.type !== "parent-key") continue
        if (!member.isPrimaryKey) continue
        const value = rootRecord.values[member.columnName]
        keys.push(value ?? '')
      }
      return keys
    },
  }))

  // 親コンポーネントにルートレコードへのアクセサを提供する
  const { update } = ReactHookForm.useFieldArray({ name: rootAggregate.path, control: formMethods.control })
  const rootRecord = ReactHookForm.useWatch({ name: `${rootAggregate.path}.0`, control: formMethods.control })
  React.useImperativeHandle(rootRecordAccessorRef, () => ({
    resetForm: () => {
      formMethods.reset(defaultValues)
    },
    updateRootRecord: (dispatch: (prev: EditableDbRecord) => EditableDbRecord) => {
      update(0, dispatch(rootRecord))
    },
  }), [rootRecord, update])
  React.useEffect(() => {
    onRootRecordChange(rootRecord)
  }, [rootRecord])

  return (
    <SingleViewContext.Provider value={singleViewContext}>
      <AggregateFormView
        itemIndexInDbRecordArray={0} // ルート集約は1つしかないので0
        aggregate={rootAggregate}
        owner={null}
        onChangeDefinition={handleChangeDefinition}
      />
    </SingleViewContext.Provider>
  )
})

/**
 * ルート集約、Child集約、子孫をもつChildren集約の編集を行う。
 */
const AggregateFormView = (props: {
  itemIndexInDbRecordArray: number
  aggregate: DataModelMetadata.Aggregate
  /** 表示対象のレコードではなくその親 */
  owner: EditableDbRecord | null
  onChangeDefinition: ((dispatch: (prev: DbTableSingleItemEditor) => DbTableSingleItemEditor) => void) | undefined
}) => {

  const {
    itemIndexInDbRecordArray,
    aggregate,
    owner,
    onChangeDefinition,
  } = props

  const thisIsChild = owner !== null

  const { setNewItemsParentMap, formMethods } = React.useContext(SingleViewContext)
  const { fields, append, update, remove } = ReactHookForm.useFieldArray({ name: aggregate.path, control: formMethods.control })
  const record = fields[itemIndexInDbRecordArray] as EditableDbRecord | undefined

  const handleCreateRecord = useEvent(() => {
    const uniqueId = UUID.generate()
    append({
      uniqueId,
      tableName: aggregate.tableName,
      values: {},
      existsInDb: false,
      changed: false,
      deleted: false,
    })
    // これが子集約の場合は親との対応関係を登録
    if (thisIsChild) {
      setNewItemsParentMap(prev => {
        prev.set(uniqueId, owner.uniqueId)
        return prev
      })
    }
  })

  const handleDeleteRecord = useEvent(() => {
    if (!record) return;
    if (record.existsInDb) {
      update(itemIndexInDbRecordArray, { ...record, deleted: true })
    } else {
      remove(itemIndexInDbRecordArray)
      setNewItemsParentMap(prev => {
        prev.delete(record.uniqueId)
        return prev
      })
    }
  })

  const handleRestoreRecord = useEvent(() => {
    if (!record) return;
    update(itemIndexInDbRecordArray, { ...record, deleted: false })
  })

  const handleChangeRecord = useEvent((record: EditableDbRecord) => {
    update(itemIndexInDbRecordArray, { ...record, changed: true })
  })

  return (
    <div className={`flex flex-col gap-px ${aggregate.type === "root" ? "p-1" : ""} ${aggregate.type === "child" ? "my-4" : ""}`}>
      {aggregate.type !== "root" && (
        <div className="flex gap-1 items-center">
          <span className="text-sm select-none text-gray-500">
            {aggregate.displayName}
          </span>
          <div className="basis-1"></div>
          <RecordStatusText record={record} className="text-sm" />
          <div className="flex-1"></div>
          {!record && (
            <Input.IconButton icon={Icon.PlusIcon} mini outline onClick={handleCreateRecord} className="self-start">
              新規作成
            </Input.IconButton>
          )}
          {record && !record.deleted && (
            <Input.IconButton icon={Icon.XMarkIcon} mini outline onClick={handleDeleteRecord} className="self-start">
              削除
            </Input.IconButton>
          )}
          {record && record.deleted && (
            <Input.IconButton icon={Icon.ArrowUturnLeftIcon} mini outline onClick={handleRestoreRecord} className="self-start">
              復元
            </Input.IconButton>
          )}
        </div>
      )}
      {(!thisIsChild || record) && aggregate.members.map(member => (
        <AggregateMemberFormView
          key={member.physicalName}
          record={record}
          onChangeRecord={handleChangeRecord}
          owner={aggregate}
          member={member}
          ownerName={`${aggregate.path}.${itemIndexInDbRecordArray}`}
        />
      ))}
    </div>
  )
}

const AggregateMemberFormView = ({ record, onChangeRecord, member, owner, ownerName }: {
  record: EditableDbRecord | undefined,
  onChangeRecord: (value: EditableDbRecord) => void,
  member: DataModelMetadata.AggregateMember | DataModelMetadata.Aggregate
  owner: DataModelMetadata.Aggregate
  ownerName: string
}) => {

  const {
    formMethods,
    tableMetadataHelper,
  } = React.useContext(SingleViewContext)

  // 読み取り専用判定
  const isReadOnly = React.useMemo(() => {
    // 表示されないので未定義
    if (member.type === "root") return undefined
    if (member.type === "child") return undefined
    if (member.type === "children") return undefined
    if (member.type === "parent-key") return undefined
    if (member.type === "own-column") return member.isPrimaryKey && record?.existsInDb
    if (member.type === "ref-key") return member.isPrimaryKey && record?.existsInDb
  }, [member, record?.existsInDb])

  // テキストボックスの値変更時
  const handleChangeText: React.ChangeEventHandler<HTMLInputElement> = useEvent(e => {
    if (!record) return;
    if (member.type !== "own-column" && member.type !== "ref-key") return;
    const clone = window.structuredClone(record)
    clone.values[member.columnName] = e.target.value === '' ? null : e.target.value
    onChangeRecord(clone)
  })

  // 参照キーの検索
  const [refKeySearchDialogProps, setRefKeySearchDialogProps] = React.useState<DbTableSingleItemSelectorDialogProps | null>(null)
  const handleSearch = useEvent(() => {
    if (member.type !== "ref-key") return;
    const refToTableMetadata = tableMetadataHelper.getRefTo(member)
    if (!refToTableMetadata) return;
    setRefKeySearchDialogProps({
      tableMetadata: refToTableMetadata,
      tableMetadataHelper: tableMetadataHelper,
      onSelect: keys => {
        if (!record) return;

        // 参照先テーブルが複合キーである可能性を考慮し、当該参照先の全キーに代入
        const clone = window.structuredClone(record)
        let index = 0
        for (const m of owner.members) {
          if (m.type !== "ref-key" || m.refToRelationName !== member.refToRelationName) continue;
          const value = keys[index] as string
          clone.values[m.columnName] = value === '' ? null : value
          index++
        }
        onChangeRecord(clone)
        setRefKeySearchDialogProps(null)
      },
      onCancel: () => {
        setRefKeySearchDialogProps(null)
      },
    })
  })

  // ルート集約はAggregateViewで処理する。ここには来ない
  if (member.type === "root") {
    throw new Error("ルート集約はAggregateViewで処理する")
  }

  // 親の主キー（非表示）
  if (member.type === "parent-key") {
    return undefined
  }

  // テーブル自身の属性のカラム、または外部参照のキー項目
  if (member.type === "own-column" || member.type === "ref-key") {
    return (
      <div className="flex gap-1 items-center">
        <div className="basis-40 text-sm break-all select-none text-gray-600">
          {member.columnName}
        </div>
        <div className={`flex-1 flex ${isReadOnly ? '' : 'bg-white border border-gray-500'}`}>
          {member.type === "ref-key" && !isReadOnly && (
            <Input.IconButton icon={Icon.MagnifyingGlassIcon} hideText mini onClick={handleSearch}>
              検索
            </Input.IconButton>
          )}
          <input
            type="text"
            value={record?.values[member.columnName] ?? ''}
            onChange={handleChangeText}
            spellCheck={false}
            placeholder="NULL"
            className="flex-1 px-1 outline-none placeholder:text-gray-300"
            readOnly={isReadOnly}
          />
        </div>
        {refKeySearchDialogProps && (
          <DbTableSingleItemSelectorDialog {...refKeySearchDialogProps} />
        )}
      </div>
    )
  }

  if (member.type === "child") {
    const childAggregate = tableMetadataHelper.allAggregates().find(a => a.tableName === member.tableName)
    if (!childAggregate) {
      throw new Error("子集約が見つかりません")
    }
    return (
      <AggregateFormView
        itemIndexInDbRecordArray={0}
        aggregate={childAggregate}
        owner={record ?? null}
        onChangeDefinition={undefined}
      />
    )
  }

  if (member.type === "children") {
    return (
      <AggregateGridView
        itemIndexInForm={0}
        owner={record ?? null}
        ownerMetadata={owner}
        childrenMetadata={member}
        ownerName={ownerName}
      />
    )
  }

  return (
    <div>
      未実装: {member.type}
    </div>
  )
}

/**
 * TODO: childrenの中にchildやchildrenがあるケースは未対応
 */
const AggregateGridView = (props: {
  itemIndexInForm: number
  owner: EditableDbRecord | null
  childrenMetadata: DataModelMetadata.Aggregate
  ownerMetadata: DataModelMetadata.Aggregate
  ownerName: string
}) => {

  const {
    itemIndexInForm,
    childrenMetadata,
    ownerMetadata,
    ownerName,
  } = props

  const {
    formMethods,
    tableMetadataHelper,
    setNewItemsParentMap,
  } = React.useContext(SingleViewContext)

  const { control } = formMethods
  const { fields, append, remove, update } = ReactHookForm.useFieldArray({ name: childrenMetadata.path, control })
  const gridRef = React.useRef<Layout.EditableGridRef<ReactHookForm.FieldArrayWithId<SingleViewFormType, string, "id">>>(null)

  const handleChangeRow: Layout.RowChangeEvent<ReactHookForm.FieldArrayWithId<SingleViewFormType, string, "id">> = useEvent(e => {
    for (const r of e.changedRows) {
      update(r.rowIndex, { ...r.newRow, changed: true })
    }
  })

  const { getColumnDefs, ForeignKeyReferenceDialog } = useDbRecordGridColumnDef(
    'single-view-children',
    childrenMetadata,
    tableMetadataHelper,
    update,
  )

  // グリッドの列幅の自動保存
  const { savedDesign, updateDesign } = useEditorDesign()
  const gridColumnStorage: Layout.EditableGridAutoSaveStorage = React.useMemo(() => ({
    loadState: () => {
      return savedDesign[childrenMetadata.path]?.singleViewGridLayout ?? null
    },
    saveState: (gridState) => {
      updateDesign(childrenMetadata.path, 'singleViewGridLayout', gridState)
    },
  }), [savedDesign, updateDesign, childrenMetadata.path])

  const handleAddRow = useEvent(() => {
    const uniqueId = UUID.generate()
    append({
      uniqueId,
      tableName: childrenMetadata.tableName,
      values: {},
      existsInDb: false,
      changed: false,
      deleted: false,
    })
    if (props.owner) {
      setNewItemsParentMap(prev => {
        prev.set(uniqueId, props.owner!.uniqueId)
        return prev
      })
    }
  })

  const handleRemoveRow = useEvent(() => {
    const selectedRows = gridRef.current?.getSelectedRows() ?? []
    const removedItems: { row: EditableDbRecord, rowIndex: number }[] = []
    for (const item of selectedRows) {
      if (item.row.existsInDb) {
        update(item.rowIndex, { ...item.row, deleted: true })
      } else {
        removedItems.push(item)
      }
    }
    remove(removedItems.map(r => r.rowIndex))
    setNewItemsParentMap(prev => {
      for (const r of removedItems) prev.delete(r.row.uniqueId)
      return prev
    })
  })

  return (
    <div className="h-56 w-full flex flex-col overflow-y-auto resize-y">
      <div className="flex flex-wrap gap-1 py-px">
        <span className="text-sm select-none text-gray-500">
          {childrenMetadata.displayName}
        </span>
        <div className="basis-2"></div>
        <Input.IconButton icon={Icon.PlusIcon} mini outline onClick={handleAddRow}>
          追加
        </Input.IconButton>
        <Input.IconButton icon={Icon.MinusIcon} mini outline onClick={handleRemoveRow}>
          削除
        </Input.IconButton>
      </div>
      <Layout.EditableGrid
        ref={gridRef}
        rows={fields}
        getColumnDefs={getColumnDefs as unknown as Layout.GetColumnDefsFunction<ReactHookForm.FieldArrayWithId<SingleViewFormType, string, "id">>}
        onChangeRow={handleChangeRow}
        storage={gridColumnStorage}
        className="flex-1 border border-gray-400"
      />
      {ForeignKeyReferenceDialog}
    </div>
  )
}
