import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { EditableDbRecord, DbTableSingleItemEditor, ReloadTrigger, TableMetadataHelper } from "./types"
import useQueryEditorServerApi from "./useQueryEditorServerApi"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useEvent from "react-use-event-hook"
import { DbTableEditorViewRef } from "./DbTableMultiEditorView"
import { useDbRecordGridColumnDef } from "./useDbRecordGridColumnDef"

export type DbTableSingleItemSelectorDialogProps = {
  tableMetadata: DataModelMetadata.Aggregate
  tableMetadataHelper: TableMetadataHelper
  onSelect: (keys: string[]) => void
  onCancel: () => void
}

/**
 * どのコードを編集するかを選択するダイアログ
 */
export const DbTableSingleItemSelectorDialog = ({
  tableMetadata,
  tableMetadataHelper,
  onSelect,
  onCancel,
}: DbTableSingleItemSelectorDialogProps) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [records, setRecords] = React.useState<EditableDbRecord[]>()
  const [error, setError] = React.useState<string | null>(null)

  React.useEffect(() => {
    (async () => {
      const res = await getDbRecords({
        tableName: tableMetadata.tableName,
        whereClause: "",
      })
      if (res.ok) {
        setRecords(res.data.records)
      } else {
        setError(res.error)
      }
    })()
  }, [])

  const columnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    // 選択
    const selectColumn = cellType.other('', {
      defaultWidth: 60,
      isFixed: true,
      renderCell: cell => {

        const handleClick = () => {
          const primaryKeyColumns = tableMetadata.members
            .filter(c => (c.type === "own-column" || c.type === "parent-key" || c.type === "ref-key") && c.isPrimaryKey)
            .map(c => (c as DataModelMetadata.AggregateMember).columnName)
          const primaryKeyValues = primaryKeyColumns.map(c => cell.row.original.values[c] ?? '')
          onSelect(primaryKeyValues)
        }

        return (
          <Input.IconButton underline mini onClick={handleClick}>
            選択
          </Input.IconButton>
        )
      },
    })

    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []
    for (const column of tableMetadata.members) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは別のウィンドウ
        continue
      } else if (column.type === "own-column" || column.type === "parent-key" || column.type === "ref-key") {
        valueColumns.push(cellType.text(
          `values.${column.columnName}` as ReactHookForm.FieldPathByValue<EditableDbRecord, string | undefined>,
          column.columnName ?? '',
          {}))
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      selectColumn,
      ...valueColumns,
    ]
  }, [tableMetadata])

  return (
    <Layout.ModalDialog
      open
      className="relative w-[80vw] h-[80vh] bg-white flex flex-col gap-1 relative border border-gray-400"
    >
      <div className="h-full w-full flex flex-col p-1 gap-1">

        <div className="flex gap-1 p-1">
          <span className="font-bold">
            編集対象データを選択してください。
          </span>
          <div className="flex-1"></div>
          <Input.IconButton outline mini onClick={onCancel}>
            キャンセル
          </Input.IconButton>
        </div>

        {error && (
          <div className="text-red-500 flex-1">
            {error}
          </div>
        )}
        {records && (
          <Layout.EditableGrid
            rows={records}
            getColumnDefs={columnDefs}
            className="flex-1"
          />
        )}
      </div>

      {!error && !records && (
        <Layout.NowLoading />
      )}
    </Layout.ModalDialog>
  )
}

// ------------------------------------

type DbTableSingleEditViewProps = {
  itemIndex: number
  value: DbTableSingleItemEditor
  onChangeDefinition: (index: number, value: DbTableSingleItemEditor) => void
  onDeleteDefinition: (index: number) => void
  onIsDirtyChange: (index: number, isDirty: boolean) => void
  tableMetadataHelper: TableMetadataHelper
  trigger: ReloadTrigger
  zoom: number
  handleMouseDown: React.MouseEventHandler<Element>
}

/** SingleViewのuseFormで管理するデータの型 */
type SingleViewFormType = {
  [tablePath: string]: EditableDbRecord[]
}

type SingleViewContextType = {
  rootItemKeys: string[]
  formMethods: ReactHookForm.UseFormReturn<SingleViewFormType>
  tableMetadataHelper: TableMetadataHelper
}
const SingleViewContext = React.createContext<SingleViewContextType>({
  rootItemKeys: [],
  formMethods: {} as ReactHookForm.UseFormReturn<SingleViewFormType>,
  tableMetadataHelper: {} as TableMetadataHelper,
})

/**
 * DBレコードを集約単位で1件分編集するウィンドウ
 */
export const DbTableSingleEditView = React.forwardRef((props: DbTableSingleEditViewProps, ref: React.ForwardedRef<DbTableEditorViewRef>) => {

  const {
    itemIndex,
    value: propsValue,
    onChangeDefinition,
    onDeleteDefinition,
    onIsDirtyChange,
    tableMetadataHelper,
    trigger,
    zoom,
    handleMouseDown,
  } = props
  const [isLoaded, setIsLoaded] = React.useState(false)
  const [error, setError] = React.useState<string | null>(null)
  const { getDbRecords } = useQueryEditorServerApi()
  const [defaultValues, setDefaultValues] = React.useState<SingleViewFormType>()
  const [rootAggregate, setRootAggregate] = React.useState<DataModelMetadata.Aggregate | null>(null)

  React.useEffect(() => {
    (async () => {
      try {
        setIsLoaded(false)
        setError(null)
        setDefaultValues(undefined)

        const rootAggregate = tableMetadataHelper.rootAggregates().find(a => a.tableName === propsValue.rootTableName)
        if (!rootAggregate) {
          setError("ルート集約が見つかりません")
          return
        }
        setRootAggregate(rootAggregate)

        // 対象のテーブルおよびその子孫テーブルそれぞれについて
        // ルート集約のテーブルの主キーで検索をかける。
        const result: SingleViewFormType = {}
        const tree = [rootAggregate, ...tableMetadataHelper.enumerateDescendants(rootAggregate)]
        for (const aggregate of tree) {
          const primaryKeyColumnNames = aggregate.members
            .filter(c => (c.type === "own-column" || c.type === "parent-key" || c.type === "ref-key") && c.isPrimaryKey)
            .map(c => (c as DataModelMetadata.AggregateMember).columnName)
          const whereClause = propsValue.rootItemKey.map((pk, index) => `${primaryKeyColumnNames[index]} = '${pk.replace(/'/g, "''")}'`).join(" AND ")
          const res = await getDbRecords({
            tableName: aggregate.tableName,
            whereClause,
          })
          if (res.ok) {
            // ルート集約が見つからなかったら終わり
            if (aggregate.path === rootAggregate.path && res.data.records.length === 0) {
              setError("対象レコードが見つかりません")
              return
            }
            result[aggregate.path] = res.data.records
          } else {
            setError(res.error ?? "不明なエラーが発生しました")
          }
        }
        setDefaultValues(result)

      } finally {
        setIsLoaded(true)
      }
    })()
  }, [trigger])

  const handleDeleteWindow = useEvent(() => {
    onDeleteDefinition(itemIndex)
  })

  const handleClickReset = useEvent(() => {
    if (!window.confirm('データの変更を取り消しますか？')) return
    setDefaultValues(defaultValues)
    setError(null)
  })

  return (
    <div className="bg-gray-200 border border-gray-300 h-full flex flex-col">
      {/* ヘッダ */}
      <div className="flex gap-1 p-1 bg-gray-100 border-b border-gray-300 cursor-grab">
        <span onMouseDown={handleMouseDown} className="flex-1 select-none">
          {rootAggregate?.displayName}
          （{propsValue.rootItemKey.join(", ")}）
        </span>

        {defaultValues && (
          <Input.IconButton icon={Icon.ArrowUturnLeftIcon} mini outline onClick={handleClickReset}>
            リセット
          </Input.IconButton>
        )}
        <Input.IconButton icon={Icon.XMarkIcon} hideText onClick={handleDeleteWindow}>
          削除
        </Input.IconButton>
      </div>

      {/* ボディ */}
      <div className="flex-1 overflow-y-auto relative">
        {error && (
          <div className="text-red-500">{error}</div>
        )}
        {(!isLoaded || !rootAggregate || !defaultValues) && (
          <Layout.NowLoading />
        )}
        {rootAggregate && defaultValues && (
          <DbTableSingleEditViewAfterLoaded
            {...props}
            ref={ref}
            rootAggregate={rootAggregate}
            defaultValues={defaultValues}
          />
        )}
      </div>
    </div>
  )
})

const DbTableSingleEditViewAfterLoaded = React.forwardRef((props: DbTableSingleEditViewProps & {
  rootAggregate: DataModelMetadata.Aggregate
  defaultValues: SingleViewFormType
}, ref: React.ForwardedRef<DbTableEditorViewRef>) => {
  const {
    itemIndex,
    value,
    onChangeDefinition,
    onDeleteDefinition,
    onIsDirtyChange,
    tableMetadataHelper,
    handleMouseDown,
    rootAggregate,
    defaultValues,
  } = props

  const formMethods = ReactHookForm.useForm<SingleViewFormType>({
    defaultValues,
  })

  React.useEffect(() => {
    onIsDirtyChange(itemIndex, formMethods.formState.isDirty)
  }, [formMethods.formState.isDirty])

  const singleViewContext: SingleViewContextType = React.useMemo(() => ({
    rootItemKeys: value.rootItemKey,
    formMethods,
    tableMetadataHelper,
  }), [value.rootItemKey, formMethods, tableMetadataHelper])

  React.useImperativeHandle(ref, () => ({
    getCurrentRecords: () => {
      const result: EditableDbRecord[] = []
      for (const records of Object.values(formMethods.getValues())) {
        result.push(...records)
      }
      return result
    },
  }))

  return (
    <SingleViewContext.Provider value={singleViewContext}>
      <AggregateFormView
        itemIndexInDbRecordArray={0} // ルート集約は1つしかないので0
        aggregate={rootAggregate}
      />
    </SingleViewContext.Provider>
  )
})

const AggregateFormView = (props: {
  itemIndexInDbRecordArray: number
  aggregate: DataModelMetadata.Aggregate
}) => {

  const {
    itemIndexInDbRecordArray,
    aggregate,
  } = props

  const { formMethods } = React.useContext(SingleViewContext)
  const { fields, update } = ReactHookForm.useFieldArray({ name: aggregate.path, control: formMethods.control })

  const handleChangeRecord = useEvent((record: EditableDbRecord) => {
    update(itemIndexInDbRecordArray, { ...record, changed: true })
  })

  return (
    <div className={`flex flex-col gap-px ${aggregate.type === "root" ? "p-1" : ""} ${aggregate.type === "child" ? "my-4" : ""}`}>
      {aggregate.type !== "root" && (
        <span className="text-sm select-none text-gray-500">
          {aggregate.displayName}
        </span>
      )}
      {aggregate.members.map(member => (
        <AggregateMemberFormView
          key={member.physicalName}
          record={fields[itemIndexInDbRecordArray]}
          onChangeRecord={handleChangeRecord}
          owner={aggregate}
          member={member}
          ownerName={`${aggregate.path}.${itemIndexInDbRecordArray}`}
        />
      ))}
    </div>
  )
}

const AggregateMemberFormView = ({ record, onChangeRecord, member, owner, ownerName }: {
  record: EditableDbRecord,
  onChangeRecord: (value: EditableDbRecord) => void,
  member: DataModelMetadata.AggregateMember | DataModelMetadata.Aggregate
  owner: DataModelMetadata.Aggregate
  ownerName: string
}) => {

  const {
    formMethods,
    tableMetadataHelper,
  } = React.useContext(SingleViewContext)

  // 読み取り専用判定
  const isReadOnly = React.useMemo(() => {
    // 表示されないので未定義
    if (member.type === "root") return undefined
    if (member.type === "child") return undefined
    if (member.type === "children") return undefined
    if (member.type === "parent-key") return undefined
    if (member.type === "own-column") return member.isPrimaryKey && record.existsInDb
    if (member.type === "ref-key") return member.isPrimaryKey && record.existsInDb
  }, [member, record.existsInDb])

  // テキストボックスの値変更時
  const handleChangeText: React.ChangeEventHandler<HTMLInputElement> = useEvent(e => {
    if (member.type !== "own-column" && member.type !== "ref-key") return;
    const clone = window.structuredClone(record)
    clone.values[member.columnName] = e.target.value === '' ? null : e.target.value
    onChangeRecord(clone)
  })

  // 参照キーの検索
  const [refKeySearchDialogProps, setRefKeySearchDialogProps] = React.useState<DbTableSingleItemSelectorDialogProps | null>(null)
  const handleSearch = useEvent(() => {
    if (member.type !== "ref-key") return;
    const refToTableMetadata = tableMetadataHelper.getRefTo(member)
    if (!refToTableMetadata) return;
    setRefKeySearchDialogProps({
      tableMetadata: refToTableMetadata,
      tableMetadataHelper: tableMetadataHelper,
      onSelect: keys => {
        // 参照先テーブルが複合キーである可能性を考慮し、当該参照先の全キーに代入
        const clone = window.structuredClone(record)
        let index = 0
        for (const m of owner.members) {
          if (m.type !== "ref-key" || m.refToRelationName !== member.refToRelationName) continue;
          const value = keys[index] as string
          clone.values[m.columnName] = value === '' ? null : value
          index++
        }
        onChangeRecord(clone)
        setRefKeySearchDialogProps(null)
      },
      onCancel: () => {
        setRefKeySearchDialogProps(null)
      },
    })
  })

  // ルート集約はAggregateViewで処理する。ここには来ない
  if (member.type === "root") {
    throw new Error("ルート集約はAggregateViewで処理する")
  }

  // 親の主キー（非表示）
  if (member.type === "parent-key") {
    return undefined
  }

  // テーブル自身の属性のカラム、または外部参照のキー項目
  if (member.type === "own-column" || member.type === "ref-key") {
    return (
      <div className="flex gap-1 items-center">
        <div className="basis-40 text-sm break-all select-none text-gray-600">
          {member.columnName}
        </div>
        <div className={`flex-1 flex ${isReadOnly ? '' : 'bg-white border border-gray-500'}`}>
          {member.type === "ref-key" && !isReadOnly && (
            <Input.IconButton icon={Icon.MagnifyingGlassIcon} hideText mini onClick={handleSearch}>
              検索
            </Input.IconButton>
          )}
          <input
            type="text"
            value={record.values[member.columnName] ?? ''}
            onChange={handleChangeText}
            spellCheck={false}
            placeholder="NULL"
            className="flex-1 px-1 outline-none placeholder:text-gray-300"
            readOnly={isReadOnly}
          />
        </div>
        {refKeySearchDialogProps && (
          <DbTableSingleItemSelectorDialog {...refKeySearchDialogProps} />
        )}
      </div>
    )
  }

  if (member.type === "child") {
    const childAggregate = tableMetadataHelper.allAggregates().find(a => a.tableName === member.tableName)
    if (!childAggregate) {
      throw new Error("子集約が見つかりません")
    }
    return (
      <AggregateFormView
        itemIndexInDbRecordArray={0}
        aggregate={childAggregate}
      />
    )
  }

  if (member.type === "children") {
    return (
      <AggregateGridView
        itemIndexInForm={0}
        owner={owner}
        childrenAggregate={member}
        ownerName={ownerName}
      />
    )
  }

  return (
    <div>
      未実装: {member.type}
    </div>
  )
}

/**
 * TODO: childrenの中にchildやchildrenがあるケースは未対応
 */
const AggregateGridView = (props: {
  itemIndexInForm: number
  childrenAggregate: DataModelMetadata.Aggregate
  owner: DataModelMetadata.Aggregate
  ownerName: string
}) => {

  const {
    itemIndexInForm,
    childrenAggregate,
    owner,
    ownerName,
  } = props

  const {
    formMethods,
    tableMetadataHelper,
    rootItemKeys,
  } = React.useContext(SingleViewContext)

  const { control } = formMethods
  const { fields, append, remove, update } = ReactHookForm.useFieldArray({ name: childrenAggregate.path, control })
  const gridRef = React.useRef<Layout.EditableGridRef<ReactHookForm.FieldArrayWithId<SingleViewFormType, string, "id">>>(null)

  const handleChangeRow: Layout.RowChangeEvent<ReactHookForm.FieldArrayWithId<SingleViewFormType, string, "id">> = useEvent(e => {
    for (const r of e.changedRows) {
      update(r.rowIndex, { ...r.newRow, changed: true })
    }
  })

  const { getColumnDefs, ForeignKeyReferenceDialog } = useDbRecordGridColumnDef(
    'single-view-children',
    childrenAggregate,
    tableMetadataHelper,
    update,
  )

  const handleAddRow = useEvent(() => {
    // 親テーブルの主キーはここで設定する
    // TODO: rootItemKeysではなく直近の親のキーの値を使用する必要がある
    const values: Record<string, string> = {}
    let index = 0
    for (const m of childrenAggregate.members) {
      if (m.type !== "parent-key") continue;
      values[m.columnName] = rootItemKeys[index]
      index++
    }
    append({
      tableName: childrenAggregate.tableName,
      values,
      existsInDb: false,
      changed: false,
      deleted: false,
    })
  })

  const handleRemoveRow = useEvent(() => {
    const selectedRows = gridRef.current?.getSelectedRows() ?? []
    const removedIndexes: number[] = []
    for (const { row, rowIndex } of selectedRows) {
      if (row.existsInDb) {
        update(rowIndex, { ...row, deleted: true })
      } else {
        removedIndexes.push(rowIndex)
      }
    }
    remove(removedIndexes)
  })

  return (
    <div className="h-56 w-full flex flex-col overflow-y-auto resize-y">
      <div className="flex flex-wrap gap-1 py-px">
        <span className="text-sm select-none text-gray-500">
          {childrenAggregate.displayName}
        </span>
        <div className="basis-2"></div>
        <Input.IconButton icon={Icon.PlusIcon} mini outline onClick={handleAddRow}>
          追加
        </Input.IconButton>
        <Input.IconButton icon={Icon.MinusIcon} mini outline onClick={handleRemoveRow}>
          削除
        </Input.IconButton>
      </div>
      <Layout.EditableGrid
        ref={gridRef}
        rows={fields}
        getColumnDefs={getColumnDefs as unknown as Layout.GetColumnDefsFunction<ReactHookForm.FieldArrayWithId<SingleViewFormType, string, "id">>}
        onChangeRow={handleChangeRow}
        className="flex-1 border border-gray-400"
      />
      {ForeignKeyReferenceDialog}
    </div>
  )
}
