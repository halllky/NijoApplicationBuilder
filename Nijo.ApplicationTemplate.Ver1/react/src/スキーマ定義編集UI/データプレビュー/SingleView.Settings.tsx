import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { TableMetadataHelper } from "./types"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useEvent from "react-use-event-hook"
import { EditorDesignByAgggregate, EditorDesignByAggregateMember } from "./types"

export type DbTableSingleEditViewSettingsProps = {
  rootAggregate: DataModelMetadata.Aggregate
  tableMetadataHelper: TableMetadataHelper
  initialSettings: SingleViewSettingFormData
  onApply: (updatedSettings: SingleViewSettingFormData) => void
  onCancel: () => void
}

/**
 * フォーム用の型定義。
 * SingleViewの場合は一度にその集約ツリーのすべての集約が編集対象になる。
 */
export type SingleViewSettingFormData = {
  [aggregatePath: string]: EditorDesignByAgggregate
}

/**
 * SinlgeViewの表示設定を編集するダイアログ
 */
export const DbTableSingleEditViewSettings = ({
  rootAggregate,
  tableMetadataHelper,
  initialSettings,
  onApply,
  onCancel,
}: DbTableSingleEditViewSettingsProps) => {

  // 集約ツリーの全メンバーを取得
  const allMembers = React.useMemo(() => {
    const result: Array<{
      member: DataModelMetadata.AggregateMember
      aggregate: DataModelMetadata.Aggregate
      memberKey: string
    }> = []

    const collectMembers = (agg: DataModelMetadata.Aggregate) => {
      for (const member of agg.members) {
        if (member.type === 'own-column') {
          result.push({
            member,
            aggregate: agg,
            memberKey: member.physicalName,
          })
        } else if (member.type === 'ref-key' || member.type === 'ref-parent-key') {
          if (!member.refToRelationName) continue;

          const sameKey = result.find(m => m.memberKey === member.refToRelationName)
          if (sameKey) {
            continue
          } else {
            result.push({
              member,
              aggregate: agg,
              memberKey: member.refToRelationName,
            })
          }

        } else if (member.type === 'child' || member.type === 'children') {
          collectMembers(member as DataModelMetadata.Aggregate)
        }
      }
    }

    collectMembers(rootAggregate)
    const descendants = tableMetadataHelper.enumerateDescendants(rootAggregate)
    for (const desc of descendants) {
      collectMembers(desc)
    }

    return result
  }, [rootAggregate, tableMetadataHelper])

  const formMethods = ReactHookForm.useForm<SingleViewSettingFormData>({
    defaultValues: initialSettings,
  })
  const { register, handleSubmit, control, setValue } = formMethods

  // キャンセル
  const handleCancel = useEvent(() => {
    onCancel()
  })

  return (
    <Layout.ModalDialog
      open
      className="relative w-[90vw] max-w-4xl h-[90vh] bg-white flex flex-col gap-1 relative border border-gray-400"
      onOutsideClick={handleCancel}
    >
      <ReactHookForm.FormProvider {...formMethods}>
        <form onSubmit={handleSubmit(onApply)} className="flex flex-col h-full">

          <h1 className="font-bold select-none text-gray-700 px-4 py-2 border-b border-gray-200">
            表示設定 - {rootAggregate.displayName}
          </h1>

          <div className="flex-1 overflow-y-auto px-4 py-4 space-y-6">
            {/* 基本設定 */}
            <div className="space-y-4">
              <h2 className="text-lg font-medium text-gray-700">基本設定</h2>
              <div className="flex items-center gap-2">
                <label className="w-48 text-sm text-gray-500">ラベルの横幅</label>
                <input
                  type="text"
                  {...register(`${rootAggregate.path}.singleViewLabelWidth`)}
                  className="basis-24 w-24 px-2 py-1 border border-gray-400"
                  placeholder="10em"
                />
                <span className="flex-1 text-xs text-gray-500">
                  ※「10rem」などCSSの属性値で定義してください。
                </span>
              </div>
            </div>

            {/* メンバー設定 */}
            {allMembers.length > 0 && (
              <div className="space-y-4">
                <h2 className="text-lg font-medium text-gray-700">メンバー設定</h2>
                <div className="space-y-3">
                  {allMembers.map(({ memberKey, member, aggregate: owner }, index) => (
                    <MemberSettingRow
                      key={index}
                      aggregatePath={owner.path}
                      memberKey={memberKey}
                      member={member}
                      tableMetadataHelper={tableMetadataHelper}
                      register={register}
                      control={control}
                      setValue={setValue}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>

          <div className="flex justify-end items-center gap-2 py-2 px-4 border-t border-gray-200">
            <Input.IconButton onClick={handleCancel}>キャンセル</Input.IconButton>
            <Input.IconButton submit fill>適用</Input.IconButton>
          </div>
        </form>
      </ReactHookForm.FormProvider>
    </Layout.ModalDialog>
  )
}

/**
 * 各メンバーの設定行
 */
const MemberSettingRow = ({
  aggregatePath,
  memberKey,
  member,
  tableMetadataHelper,
  register,
  control,
  setValue,
}: {
  aggregatePath: string
  memberKey: string
  member: DataModelMetadata.AggregateMember
  tableMetadataHelper: TableMetadataHelper
  register: ReactHookForm.UseFormRegister<SingleViewSettingFormData>
  control: ReactHookForm.Control<SingleViewSettingFormData>
  setValue: ReactHookForm.UseFormSetValue<SingleViewSettingFormData>
}) => {
  const memberSetting = ReactHookForm.useWatch({ control, name: `${aggregatePath}.membersDesign.${memberKey}` })

  // 参照先テーブルの情報を取得
  const refToAggregate = React.useMemo(() => {
    if (member.type !== 'ref-key' && member.type !== 'ref-parent-key' || !member.refToAggregatePath) return null
    return tableMetadataHelper.allAggregates().find(a => a.path === member.refToAggregatePath)
  }, [member, tableMetadataHelper])

  // 参照先テーブルのカラム一覧（外部キー以外）
  const refToColumns = React.useMemo(() => {
    if (!refToAggregate) return []
    return refToAggregate.members
      .filter((m): m is DataModelMetadata.AggregateMember =>
        m.type === 'own-column' && !m.isPrimaryKey
      )
      .map(m => ({
        columnName: m.columnName,
        displayName: m.displayName,
      }))
  }, [refToAggregate])

  const handleCheckboxChange = useEvent((columnName: string, checked: boolean) => {
    const currentColumns = memberSetting?.singleViewRefDisplayColumnNames || []
    const newColumns = checked
      ? [...currentColumns, columnName]
      : currentColumns.filter(c => c !== columnName)

    setValue(`${aggregatePath}.membersDesign.${memberKey}.singleViewRefDisplayColumnNames`, newColumns)
  })

  return (
    <div className="border border-gray-300 rounded p-1 space-y-2">
      <div className="flex items-center gap-2">
        <span className="font-medium text-sm">{aggregatePath}/{member.displayName}</span>
        <span className="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">
          {member.type}
        </span>
      </div>

      {member.type === 'own-column' && (
        <div className="text-sm text-gray-500 pl-4">
          設定項目はありません
        </div>
      )}

      {(member.type === 'ref-key' || member.type === 'ref-parent-key') && (
        <div className="pl-4 space-y-2">
          <div className="text-sm font-medium text-gray-700">
            参照先テーブルのカラムのうちこの画面に表示するもの
          </div>
          {refToColumns.length === 0 ? (
            <div className="text-sm text-gray-500">
              参照先テーブルに表示可能なカラムがありません
            </div>
          ) : (
            <div className="grid grid-cols-2 gap-2">
              {refToColumns.map(col => (
                <label key={col.columnName} className="flex items-center gap-2 text-sm">
                  <input
                    type="checkbox"
                    checked={memberSetting?.singleViewRefDisplayColumnNames?.includes(col.columnName) || false}
                    onChange={(e) => handleCheckboxChange(col.columnName, e.target.checked)}
                    className="rounded"
                  />
                  <span className="truncate">{col.displayName}</span>
                </label>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  )
}
