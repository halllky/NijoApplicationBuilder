import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { EditableDbRecord, TableMetadataHelper } from "./types"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useQueryEditorServerApi from "./useQueryEditorServerApi"
import { RecordStatusText } from "./RecordStatusText"
import { DataPreviewGlobalContext } from "./DataPreviewGlobalContext"

export const useDbRecordGridColumnDef = (
  mode: 'single-view-children' | 'multi-record-editor',
  tableMetadata: DataModelMetadata.Aggregate,
  tableMetadataHelper: TableMetadataHelper | undefined,
  useFieldArrayUpdate: (index: number, value: EditableDbRecord) => void,
  designMode: 'singleView' | 'multiView',
  ownerIsReadOnly: boolean,
) => {
  const [foreignKeyReferenceDialog, setForeignKeyReferenceDialog] = React.useState<ForeignKeyReferenceDialogProps | null>(null)

  // 参照先のカラム名
  const { control } = React.useContext(DataPreviewGlobalContext)
  const aggregateSettings = ReactHookForm.useWatch({ control, name: `design.${tableMetadata.path}` })

  const getColumnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    const status = cellType.other('', {
      defaultWidth: 40,
      enableResizing: false,
      isFixed: true,
      isReadOnly: () => true,
      renderCell: cell => (
        <div className="w-full h-full bg-gray-200">
          <RecordStatusText record={cell.row.original} className="text-sm" />
        </div>
      ),
    })

    const thisTableMetadata = tableMetadataHelper?.allAggregates().find(table => table.tableName === tableMetadata.tableName)
    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []

    for (let index = 0; index < (thisTableMetadata?.members ?? []).length; index++) {
      const column = thisTableMetadata!.members[index]

      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは表示しない
        continue

      }

      if (column.type === "ref-key" || column.type === "own-column" || column.type === "parent-key" || column.type === "ref-parent-key") {

        // SingleViewの子テーブルの場合は親キーの列は表示しない
        if (mode === 'single-view-children' && column.refToRelationName == null && column.type === "parent-key") {
          continue
        }

        // 表示名の設定を取得
        const displayName = (column.type === "own-column" || column.type === "parent-key")
          ? (aggregateSettings?.membersDesign?.[column.columnName]?.displayName || column.columnName)
          : (mode === 'single-view-children'
            ? (aggregateSettings?.membersDesign?.[column.refToRelationName ?? '']?.singleViewRefDisplayColumnNamesDisplayNames?.[column.refToColumnName ?? ''] ?? column.columnName)
            : (aggregateSettings?.membersDesign?.[column.refToRelationName ?? '']?.multiViewRefDisplayColumnNamesDisplayNames?.[column.refToColumnName ?? ''] ?? column.columnName))

        valueColumns.push(cellType.other(displayName, {
          // DBに存在する主キーの列は編集不可。
          isReadOnly: row => row.existsInDb && column.isPrimaryKey,

          onStartEditing: e => {
            e.setEditorInitialValue(e.row.values[column.columnName] ?? '')
          },

          onEndEditing: e => {
            const clone = window.structuredClone(e.row)
            clone.values[column.columnName] = e.value === '' ? null : e.value
            e.setEditedRow(clone)
          },

          renderCell: cell => {
            const isReadOnly = ownerIsReadOnly || cell.row.original.existsInDb && column.isPrimaryKey

            // 外部キーの列の場合は検索ダイアログから選択できるようにする
            const handleClick = () => {
              const refToAggregate = tableMetadataHelper?.getRefTo(column)
              if (!refToAggregate) {
                throw new Error(`外部参照先テーブルが見つかりません: ${column.refToAggregatePath}`)
              }
              setForeignKeyReferenceDialog({
                tableMetadata: refToAggregate,
                onSelect: selectedRecord => {
                  // 複合キーの考慮のため、その相手方を参照するキーの値を全部代入する
                  const clone = window.structuredClone(cell.row.original)
                  for (const m of thisTableMetadata?.members ?? []) {
                    if (m.type !== "ref-key" && m.type !== "ref-parent-key" || m.refToRelationName !== column.refToRelationName) continue;
                    if (!m.refToColumnName) throw new Error(`${m.columnName}の参照先カラムが見つかりません。`) // ありえないが念のため
                    const value = selectedRecord.values[m.refToColumnName]
                    clone.values[m.columnName] = value === '' ? null : value
                  }
                  clone.changed = true
                  useFieldArrayUpdate(cell.row.index, clone)
                  setForeignKeyReferenceDialog(null)
                },
                onCancel: () => setForeignKeyReferenceDialog(null),
              })
            }

            const isNull = cell.row.original.values[column.columnName] === null
              || cell.row.original.values[column.columnName] === undefined

            return (
              <div className="w-full flex overflow-hidden px-1">

                {/* 検索ダイアログ展開ボタン */}
                {(column.type === "ref-key" || column.type === "ref-parent-key") && !isReadOnly && (
                  <Input.IconButton icon={Icon.MagnifyingGlassIcon} hideText mini onClick={handleClick}>
                    検索
                  </Input.IconButton>
                )}

                <span className={`flex-1 truncate ${isNull ? 'text-gray-300' : ''}`}>
                  {isNull ? 'NULL' : cell.row.original.values[column.columnName]}
                </span>
              </div>
            )
          },
        }))

        // 外部参照の場合、設定に応じて参照先テーブルの追加カラムを表示
        const nextColumn = thisTableMetadata?.members[index + 1]
        const isLastOfSameRefToRelationName = column.refToRelationName
          && (nextColumn === undefined || nextColumn.refToRelationName !== column.refToRelationName)
        if (isLastOfSameRefToRelationName) {
          const refSettings = aggregateSettings?.membersDesign?.[column.refToRelationName!]
          const additionalColumnNames = designMode === 'singleView'
            ? refSettings?.singleViewRefDisplayColumnNames
            : refSettings?.multiViewRefDisplayColumnNames
          const refToAggregate = tableMetadataHelper?.getRefTo(column)
          if (!refToAggregate) throw new Error(`外部参照先テーブルが見つかりません: ${column.refToAggregatePath}`)

          for (const additionalColumnName of additionalColumnNames ?? []) {
            const refColumn = refToAggregate.members.find(m => m.columnName === additionalColumnName) as DataModelMetadata.AggregateMember | undefined
            if (!refColumn) throw new Error(`外部参照先テーブルのカラムが見つかりません: ${refToAggregate.tableName} ${additionalColumnName}`)

            // 表示名の設定を取得
            const displayNamesSettings = designMode === 'singleView'
              ? refSettings?.singleViewRefDisplayColumnNamesDisplayNames
              : refSettings?.multiViewRefDisplayColumnNamesDisplayNames
            const displayName = displayNamesSettings?.[additionalColumnName] || additionalColumnName

            valueColumns.push(cellType.other(displayName, {
              isReadOnly: () => true, // 常に読み取り専用
              renderCell: cell => {
                return (
                  <RefColumnCellRenderer
                    record={cell.row.original}
                    foreignKeyColumn={column}
                    refColumn={refColumn}
                    refToAggregate={refToAggregate}
                    ownerTableMetadata={tableMetadata}
                  />
                )
              },
            }))
          }
        }
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      status,
      ...valueColumns,
    ]
  }, [tableMetadataHelper, aggregateSettings, designMode, ownerIsReadOnly])

  return {
    /** 列定義 */
    getColumnDefs,

    /** 外部参照テーブルのレコード選択ダイアログ。呼び出し元に配置する必要がある。 */
    ForeignKeyReferenceDialog: (
      foreignKeyReferenceDialog ? (
        <ForeignKeyReferenceDialog
          tableMetadata={foreignKeyReferenceDialog.tableMetadata}
          onSelect={foreignKeyReferenceDialog.onSelect}
          onCancel={foreignKeyReferenceDialog.onCancel}
        />
      ) : null
    ),
  }
}


export type ForeignKeyReferenceDialogProps = {
  tableMetadata: DataModelMetadata.Aggregate
  onSelect: (record: EditableDbRecord) => void
  onCancel: () => void
}


/**
 * 外部参照テーブルのレコード選択ダイアログ
 */
export const ForeignKeyReferenceDialog = ({
  tableMetadata,
  onSelect,
  onCancel,
}: ForeignKeyReferenceDialogProps) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [records, setRecords] = React.useState<EditableDbRecord[]>()
  const [error, setError] = React.useState<string | null>(null)

  React.useEffect(() => {
    (async () => {
      const res = await getDbRecords({
        tableName: tableMetadata.tableName,
        whereClause: "",
      })
      if (res.ok) {
        setRecords(res.data.records)
      } else {
        setError(res.error)
      }
    })()
  }, [])

  const columnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    // 選択
    const selectColumn = cellType.other('', {
      defaultWidth: 60,
      isFixed: true,
      renderCell: cell => (
        <Input.IconButton underline mini onClick={() => {
          onSelect(cell.row.original)
        }}>
          選択
        </Input.IconButton>
      ),
    })

    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []

    for (const column of tableMetadata.members) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは別のウィンドウ
        continue
      } else if (column.type === "own-column" || column.type === "parent-key" || column.type === "ref-key" || column.type === "ref-parent-key") {
        valueColumns.push(cellType.text(
          `values.${column.columnName}` as ReactHookForm.FieldPathByValue<EditableDbRecord, string | undefined>,
          column.columnName ?? '',
          {}))
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      selectColumn,
      ...valueColumns,
    ]
  }, [tableMetadata])

  return (
    <Layout.ModalDialog
      open
      className="relative w-[80vw] h-[80vh] bg-white flex flex-col gap-1 relative border border-gray-400"
    >
      <div className="h-full w-full flex flex-col p-1 gap-1">

        <div className="flex gap-1 p-1">
          <span className="font-bold">
            {tableMetadata.tableName}
          </span>
          <div className="flex-1"></div>
          <Input.IconButton outline mini onClick={onCancel}>
            キャンセル
          </Input.IconButton>
        </div>

        {error && (
          <div className="text-red-500 flex-1">
            {error}
          </div>
        )}
        {records && (
          <Layout.EditableGrid
            rows={records}
            getColumnDefs={columnDefs}
            className="flex-1"
          />
        )}
      </div>

      {!error && !records && (
        <Layout.NowLoading />
      )}
    </Layout.ModalDialog>
  )
}

/**
 * 外部参照カラムのセルレンダラー（データを動的に取得して表示）
 */
const RefColumnCellRenderer = ({
  record,
  foreignKeyColumn,
  refColumn,
  refToAggregate,
  ownerTableMetadata,
}: {
  record: EditableDbRecord
  foreignKeyColumn: DataModelMetadata.AggregateMember
  refColumn: DataModelMetadata.AggregateMember
  refToAggregate: DataModelMetadata.Aggregate
  ownerTableMetadata: DataModelMetadata.Aggregate
}) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [refData, setRefData] = React.useState<string | null>(null)
  const [isLoading, setIsLoading] = React.useState(false)
  const [error, setError] = React.useState<string | null>(null)

  // 外部キーの値を取得
  const foreignKeyValue = record.values[foreignKeyColumn.columnName]

  React.useEffect(() => {
    if (!foreignKeyValue) {
      setRefData(null)
      return
    }

    const fetchRefData = async () => {
      setIsLoading(true)
      setError(null)

      try {
        // 複合キーに対応した検索条件を作成
        // 外部キーの関係名を使って関連する全ての外部キーカラムを取得
        const whereClause = ownerTableMetadata.members
          .filter((m): m is DataModelMetadata.AggregateMember =>
            (m.type === "ref-key" || m.type === "ref-parent-key") &&
            (m as DataModelMetadata.AggregateMember).refToRelationName === foreignKeyColumn.refToRelationName
          )
          .map((m) => ({ mine: m.columnName!, their: m.refToColumnName! }))
          .map(({ mine, their }) => {
            const value = record.values[mine] ?? ''
            return `${their} = '${value.replace(/'/g, "''")}'`
          })
          .join(" AND ")

        if (!whereClause) {
          setError('検索条件が作成できません')
          return
        }

        const result = await getDbRecords({
          tableName: refToAggregate.tableName,
          whereClause,
        })

        if (result.ok && result.data.records.length > 0) {
          const refRecord = result.data.records[0]
          const value = refRecord.values[refColumn.columnName]
          setRefData(value)
        } else {
          setRefData(null)
        }
      } catch (err) {
        setError('取得エラー')
      } finally {
        setIsLoading(false)
      }
    }

    fetchRefData()
  }, [record, foreignKeyColumn.refToRelationName, refToAggregate.tableName, refColumn.columnName, getDbRecords])

  if (!foreignKeyValue) {
    return <span className="text-gray-300">NULL</span>
  }

  if (isLoading) {
    return <span className="text-gray-500">読み込み中...</span>
  }

  if (error) {
    return <span className="text-red-500 text-xs">{error}</span>
  }

  const isNull = refData === null || refData === undefined
  return (
    <span className={`truncate ${isNull ? 'text-gray-300' : ''}`}>
      {isNull ? 'NULL' : refData}
    </span>
  )
}
