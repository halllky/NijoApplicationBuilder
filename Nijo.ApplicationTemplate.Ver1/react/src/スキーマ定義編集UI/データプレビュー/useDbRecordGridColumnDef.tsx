import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../../input"
import * as Layout from "../../layout"
import { EditableDbRecord, TableMetadataHelper } from "./types"
import { DataModelMetadata } from "../../__autoGenerated/util"
import useQueryEditorServerApi from "./useQueryEditorServerApi"
import { RecordStatusText } from "./RecordStatusText"
import { DataPreviewGlobalContext } from "./DataPreviewGlobalContext"

export const useDbRecordGridColumnDef = (
  mode: 'single-view-children' | 'multi-record-editor',
  tableMetadata: DataModelMetadata.Aggregate,
  tableMetadataHelper: TableMetadataHelper,
  useFieldArrayUpdate: (index: number, value: EditableDbRecord) => void,
  designMode: 'singleView' | 'multiView',
  ownerIsReadOnly: boolean,
) => {
  const [foreignKeyReferenceDialog, setForeignKeyReferenceDialog] = React.useState<ForeignKeyReferenceDialogProps | null>(null)

  // 参照先のカラム名
  const { control } = React.useContext(DataPreviewGlobalContext)
  const aggregateSettings = ReactHookForm.useWatch({ control, name: `design.${tableMetadata.path}` })

  const getColumnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    const status = cellType.other('', {
      defaultWidth: 40,
      enableResizing: false,
      isFixed: true,
      isReadOnly: () => true,
      renderCell: cell => (
        <div className="w-full h-full bg-gray-200">
          <RecordStatusText record={cell.row.original} className="text-sm" />
        </div>
      ),
    })

    const thisTableMetadata = tableMetadataHelper.allAggregates().find(table => table.tableName === tableMetadata.tableName)
    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []

    for (const column of thisTableMetadata?.members ?? []) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは表示しない
        continue

      }

      if (column.type === "ref-key" || column.type === "own-column" || column.type === "parent-key") {

        // SingleViewの子テーブルの場合は親キーの列は表示しない
        if (mode === 'single-view-children' && column.refToRelationName == null && column.type === "parent-key") {
          continue
        }

        valueColumns.push(cellType.other(column.columnName ?? '', {
          // DBに存在する主キーの列は編集不可。
          isReadOnly: row => row.existsInDb && column.isPrimaryKey,

          onStartEditing: e => {
            e.setEditorInitialValue(e.row.values[column.columnName] ?? '')
          },

          onEndEditing: e => {
            const clone = window.structuredClone(e.row)
            clone.values[column.columnName] = e.value === '' ? null : e.value
            e.setEditedRow(clone)
          },

          renderCell: cell => {
            const isReadOnly = ownerIsReadOnly || cell.row.original.existsInDb && column.isPrimaryKey

            // 外部キーの列の場合は検索ダイアログから選択できるようにする
            const handleClick = () => {
              const refToAggregate = tableMetadataHelper.getRefTo(column)
              if (!refToAggregate) {
                throw new Error(`外部参照先テーブルが見つかりません: ${column.refToAggregatePath}`)
              }
              setForeignKeyReferenceDialog({
                tableMetadata: refToAggregate,
                onSelect: selectedRecord => {
                  // 複合キーの考慮のため、その相手方を参照するキーの値を全部代入する
                  const clone = window.structuredClone(cell.row.original)
                  for (const m of thisTableMetadata?.members ?? []) {
                    if (m.type !== "ref-key" || m.refToRelationName !== column.refToRelationName) continue;
                    if (!m.refToColumnName) throw new Error(`${m.columnName}の参照先カラムが見つかりません。`) // ありえないが念のため
                    const value = selectedRecord.values[m.refToColumnName]
                    clone.values[m.columnName] = value === '' ? null : value
                  }
                  clone.changed = true
                  useFieldArrayUpdate(cell.row.index, clone)
                  setForeignKeyReferenceDialog(null)
                },
                onCancel: () => setForeignKeyReferenceDialog(null),
              })
            }

            const isNull = cell.row.original.values[column.columnName] === null
              || cell.row.original.values[column.columnName] === undefined

            return (
              <div className="w-full flex overflow-hidden px-1">

                {/* 検索ダイアログ展開ボタン */}
                {column.type === "ref-key" && !isReadOnly && (
                  <Input.IconButton icon={Icon.MagnifyingGlassIcon} hideText mini onClick={handleClick}>
                    検索
                  </Input.IconButton>
                )}

                <span className={`flex-1 truncate ${isNull ? 'text-gray-300' : ''}`}>
                  {isNull ? 'NULL' : cell.row.original.values[column.columnName]}
                </span>
              </div>
            )
          },
        }))

        // 外部参照の場合、設定に応じて参照先テーブルの追加カラムを表示
        if (column.type === "ref-key" && column.refToRelationName && designMode) {
          const refSettings = aggregateSettings?.membersDesign?.[column.refToRelationName]
          const additionalColumnNames = designMode === 'singleView'
            ? refSettings?.singleViewRefDisplayColumnNames
            : refSettings?.multiViewRefDisplayColumnNames

          if (additionalColumnNames && additionalColumnNames.length > 0) {
            const refToAggregate = tableMetadataHelper.getRefTo(column)
            if (refToAggregate) {
              for (const additionalColumnName of additionalColumnNames) {
                const refColumn = refToAggregate.members.find(m =>
                  m.type === 'own-column' && m.columnName === additionalColumnName
                ) as DataModelMetadata.AggregateMember | undefined

                if (refColumn) {
                  valueColumns.push(cellType.other(refColumn.columnName, {
                    isReadOnly: () => true, // 常に読み取り専用
                    renderCell: cell => {
                      return (
                        <RefColumnCellRenderer
                          record={cell.row.original}
                          foreignKeyColumn={column}
                          refColumn={refColumn}
                          refToAggregate={refToAggregate}
                        />
                      )
                    },
                  }))
                }
              }
            }
          }
        }
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      status,
      ...valueColumns,
    ]
  }, [tableMetadataHelper, aggregateSettings, designMode, ownerIsReadOnly])

  return {
    /** 列定義 */
    getColumnDefs,

    /** 外部参照テーブルのレコード選択ダイアログ。呼び出し元に配置する必要がある。 */
    ForeignKeyReferenceDialog: (
      foreignKeyReferenceDialog ? (
        <ForeignKeyReferenceDialog
          tableMetadata={foreignKeyReferenceDialog.tableMetadata}
          onSelect={foreignKeyReferenceDialog.onSelect}
          onCancel={foreignKeyReferenceDialog.onCancel}
        />
      ) : null
    ),
  }
}


export type ForeignKeyReferenceDialogProps = {
  tableMetadata: DataModelMetadata.Aggregate
  onSelect: (record: EditableDbRecord) => void
  onCancel: () => void
}


/**
 * 外部参照テーブルのレコード選択ダイアログ
 */
export const ForeignKeyReferenceDialog = ({
  tableMetadata,
  onSelect,
  onCancel,
}: ForeignKeyReferenceDialogProps) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [records, setRecords] = React.useState<EditableDbRecord[]>()
  const [error, setError] = React.useState<string | null>(null)

  React.useEffect(() => {
    (async () => {
      const res = await getDbRecords({
        tableName: tableMetadata.tableName,
        whereClause: "",
      })
      if (res.ok) {
        setRecords(res.data.records)
      } else {
        setError(res.error)
      }
    })()
  }, [])

  const columnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    // 選択
    const selectColumn = cellType.other('', {
      defaultWidth: 60,
      isFixed: true,
      renderCell: cell => (
        <Input.IconButton underline mini onClick={() => {
          onSelect(cell.row.original)
        }}>
          選択
        </Input.IconButton>
      ),
    })

    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []

    for (const column of tableMetadata.members) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは別のウィンドウ
        continue
      } else if (column.type === "own-column" || column.type === "parent-key" || column.type === "ref-key") {
        valueColumns.push(cellType.text(
          `values.${column.columnName}` as ReactHookForm.FieldPathByValue<EditableDbRecord, string | undefined>,
          column.columnName ?? '',
          {}))
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      selectColumn,
      ...valueColumns,
    ]
  }, [tableMetadata])

  return (
    <Layout.ModalDialog
      open
      className="relative w-[80vw] h-[80vh] bg-white flex flex-col gap-1 relative border border-gray-400"
    >
      <div className="h-full w-full flex flex-col p-1 gap-1">

        <div className="flex gap-1 p-1">
          <span className="font-bold">
            {tableMetadata.tableName}
          </span>
          <div className="flex-1"></div>
          <Input.IconButton outline mini onClick={onCancel}>
            キャンセル
          </Input.IconButton>
        </div>

        {error && (
          <div className="text-red-500 flex-1">
            {error}
          </div>
        )}
        {records && (
          <Layout.EditableGrid
            rows={records}
            getColumnDefs={columnDefs}
            className="flex-1"
          />
        )}
      </div>

      {!error && !records && (
        <Layout.NowLoading />
      )}
    </Layout.ModalDialog>
  )
}

/**
 * 外部参照カラムのセルレンダラー（データを動的に取得して表示）
 */
const RefColumnCellRenderer = ({
  record,
  foreignKeyColumn,
  refColumn,
  refToAggregate,
}: {
  record: EditableDbRecord
  foreignKeyColumn: DataModelMetadata.AggregateMember
  refColumn: DataModelMetadata.AggregateMember
  refToAggregate: DataModelMetadata.Aggregate
}) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [refData, setRefData] = React.useState<string | null>(null)
  const [isLoading, setIsLoading] = React.useState(false)
  const [error, setError] = React.useState<string | null>(null)

  // 外部キーの値を取得
  const foreignKeyValue = record.values[foreignKeyColumn.columnName]

  React.useEffect(() => {
    if (!foreignKeyValue) {
      setRefData(null)
      return
    }

    const fetchRefData = async () => {
      setIsLoading(true)
      setError(null)

      try {
        // 主キーを使って参照先データを検索
        const primaryKeyColumns = refToAggregate.members
          .filter(m => m.type === 'own-column' && m.isPrimaryKey)
          .map(m => (m as DataModelMetadata.AggregateMember).columnName)

        if (primaryKeyColumns.length === 0) {
          setError('主キーが見つかりません')
          return
        }

        // 単一主キーの場合の検索条件を作成
        const whereClause = `${primaryKeyColumns[0]} = '${String(foreignKeyValue).replace(/'/g, "''")}'`

        const result = await getDbRecords({
          tableName: refToAggregate.tableName,
          whereClause,
        })

        if (result.ok && result.data.records.length > 0) {
          const refRecord = result.data.records[0]
          const value = refRecord.values[refColumn.columnName]
          setRefData(value)
        } else {
          setRefData(null)
        }
      } catch (err) {
        setError('取得エラー')
      } finally {
        setIsLoading(false)
      }
    }

    fetchRefData()
  }, [foreignKeyValue, refToAggregate.tableName, refColumn.columnName, getDbRecords])

  if (!foreignKeyValue) {
    return <span className="text-gray-300">NULL</span>
  }

  if (isLoading) {
    return <span className="text-gray-500">読み込み中...</span>
  }

  if (error) {
    return <span className="text-red-500 text-xs">{error}</span>
  }

  const isNull = refData === null || refData === undefined
  return (
    <span className={`truncate ${isNull ? 'text-gray-300' : ''}`}>
      {isNull ? 'NULL' : refData}
    </span>
  )
}
