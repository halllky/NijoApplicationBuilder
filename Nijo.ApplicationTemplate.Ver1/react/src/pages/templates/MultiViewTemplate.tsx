import React from "react"
import useEvent from "react-use-event-hook"
import * as ReactRouter from "react-router-dom"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/solid"
import * as Input from "../../input"
import * as Layout from "../../layout"
import * as Util from "../../util"
import { Panel, PanelGroup, PanelResizeHandle, ImperativePanelGroupHandle } from "react-resizable-panels"
import { UseFormReturn, useForm, FormProvider, DefaultValues } from "react-hook-form"

/**
 * 検索条件の型定義（汎用）。
 * 実際は __autoGenerated フォルダ内に自動生成されている型定義を使用するはずなので
 * この型定義は参考程度に使用してください。不要になったら削除してください。
 */
export type SearchCondition = Record<string, unknown>

/**
 * 検索結果の型定義（汎用）。
 * 実際は __autoGenerated フォルダ内に自動生成されている型定義を使用するはずなので
 * この型定義は参考程度に使用してください。不要になったら削除してください。
 */
export type SearchResult = Record<string, unknown>

/**
 * 検索APIのレスポンス型定義。
 * 実際は __autoGenerated フォルダ内に自動生成されている型定義を使用するはずなので
 * この型定義は参考程度に使用してください。不要になったら削除してください。
 */
export type SearchResponse<T = SearchResult> = {
  currentPageItems: T[]
  totalCount: number
}

/**
 * 検索リクエストのパラメータ型定義。
 * 実際は __autoGenerated フォルダ内に自動生成されている型定義を使用するはずなので
 * この型定義は参考程度に使用してください。不要になったら削除してください。
 */
export type SearchRequest<T = SearchCondition> = {
  condition: T
  pageSize: number
  pageNo: number
}

/**
 * 一覧検索画面のテンプレート
 */
export const MultiViewTemplate = () => {

  // 検索条件用のreact-hook-form
  const defaultValues = React.useMemo(() => ({}) as SearchCondition, [])
  const reactHookFormMethods = useForm<SearchCondition>({
    defaultValues: defaultValues as DefaultValues<SearchCondition>,
  })
  const { reset, handleSubmit } = reactHookFormMethods

  // PanelGroup の Ref
  const groupRef = React.useRef<ImperativePanelGroupHandle>(null)
  // 上部パネルが閉じているかどうかの状態 (ボタン表示用)
  const [isTopPanelCollapsed, setIsTopPanelCollapsed] = React.useState(false)

  // ページネーション関連の状態
  const [currentPage, setCurrentPage] = React.useState(1)
  const [itemsPerPage, setItemsPerPage] = React.useState(10)
  const [totalCount, setTotalCount] = React.useState(0)

  // 検索結果
  const [searchResults, setSearchResults] = React.useState<SearchResult[]>([])

  // 検索中の状態
  const [isSearching, setIsSearching] = React.useState(false)

  // 列定義
  const getColumnDefs: Layout.GetColumnDefsFunction<SearchResult> = React.useCallback(cellType => {
    const columnDefs: Layout.EditableGridColumnDef<SearchResult>[] = []
    return columnDefs
  }, [])

  // 検索実行関数
  const { complexPost } = Util.useHttpRequest()
  const doSearch = React.useCallback(async (data: SearchCondition) => {
    try {
      setIsSearching(true)

      // 検索用パラメータの構築
      const searchData: SearchRequest<SearchCondition> = {
        condition: data,
        pageSize: itemsPerPage,
        pageNo: currentPage
      }

      let response: SearchResponse<SearchResult>

      // エンドポイントが提供されている場合はHTTP通信
      const apiResponse = await complexPost<SearchResponse<SearchResult>>(
        '/api/search', // 実際のエンドポイントに合わせて修正してください
        searchData
      )

      if (apiResponse) {
        response = apiResponse
      } else {
        throw new Error('検索結果がありません')
      }

      // 検索結果を設定
      if (response && response.currentPageItems) {
        setSearchResults(response.currentPageItems)
        setTotalCount(response.totalCount || 0)
      } else {
        console.log('検索結果なし')
        setSearchResults([])
        setTotalCount(0)
      }
    } catch (e) {
      console.error(e)
      setSearchResults([])
      setTotalCount(0)
    } finally {
      setIsSearching(false)
    }
  }, [currentPage, itemsPerPage, complexPost])

  // 初期検索実行
  React.useEffect(() => {
    handleSubmit(doSearch)()
  }, [handleSubmit, doSearch])

  // ページ変更時の処理
  React.useEffect(() => {
    handleSubmit(doSearch)()
  }, [currentPage, itemsPerPage])

  // クリアボタンのハンドラ
  const handleClear = React.useCallback(() => {
    reset(defaultValues)
  }, [reset, defaultValues])

  // ページ変更ハンドラー
  const handlePageChange = React.useCallback((page: number) => {
    setCurrentPage(page)
  }, [])

  // 1ページあたりの表示件数変更ハンドラー
  const handleItemsPerPageChange = React.useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setItemsPerPage(Number(e.target.value))
    setCurrentPage(1) // ページ数が変わったら1ページ目に戻る
  }, [])

  // パネルの開閉を切り替える関数
  const toggleSearchConditionPanel = React.useCallback(() => {
    const group = groupRef.current;
    if (!group) return;

    const currentLayout = group.getLayout(); // 現在のレイアウトを取得 (パーセンテージ)
    if (currentLayout.length < 2) return; // 予期しないレイアウトの場合は何もしない

    // 現在折りたたまれているか (最初のパネルのサイズが0か)
    const isCurrentlyCollapsed = currentLayout[0] < 1; // 完全に0でなくても小さい場合は畳まれているとみなす

    const newLayout = isCurrentlyCollapsed
      ? [30, 70] // 展開する (例: 上部30%)
      : [0, 100]; // 折りたたむ (上部0%)

    group.setLayout(newLayout);
  }, []);

  return (
    <Layout.PageFrame headerContent={(<>
      <Layout.PageFrameTitle>
        一覧検索
      </Layout.PageFrameTitle>
      <div className="flex-1"></div>
      <button onClick={handleClear} className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 mx-2">
        クリア
      </button>
      <div className="flex">
        <button
          className="px-3 py-1 bg-blue-500 text-white rounded-l hover:bg-blue-600"
          onClick={handleSubmit(doSearch)}
          disabled={isSearching}
        >
          検索
        </button>
        <button
          className="px-2 py-1 bg-blue-500 text-white rounded-r hover:bg-blue-600 border-l border-blue-400"
          onClick={toggleSearchConditionPanel}
        >
          {isTopPanelCollapsed ? '△' : '▽'}
        </button>
      </div>
    </>)}>

      <PanelGroup direction="vertical" ref={groupRef}>
        {/* 画面上部: 検索条件欄 */}
        <Panel
          defaultSize={30}
          minSize={10}
          collapsible
          collapsedSize={0}
          order={1}
          onCollapse={() => setIsTopPanelCollapsed(true)}
          onExpand={() => setIsTopPanelCollapsed(false)}
        >
          <div className="p-1 overflow-auto h-full">
            {/* 検索条件欄をここに配置してください。 */}
          </div>
        </Panel>

        <PanelResizeHandle className="h-2 bg-gray-200 hover:bg-gray-300 cursor-row-resize flex items-center justify-center">
          <div className="w-8 h-1 bg-gray-400 rounded"></div>
        </PanelResizeHandle>

        {/* 画面下部: 検索結果一覧 */}
        <Panel order={2} className="flex-1 flex flex-col">
          {/* 境界部分 */}
          <div className="p-1 bg-gray-100 flex justify-between items-center">
            <div>
              検索結果: <span className="font-bold">{totalCount}</span> 件
            </div>
            <div className="flex items-center gap-4">
              <div className="flex items-center">
                <label className="mr-2">表示件数:</label>
                <select
                  value={itemsPerPage}
                  onChange={handleItemsPerPageChange}
                  className="border rounded p-1"
                >
                  <option value="5">5件</option>
                  <option value="10">10件</option>
                  <option value="20">20件</option>
                  <option value="50">50件</option>
                </select>
              </div>
              <div className="flex items-center">
                <label className="mr-2">並び順:</label>
                <select className="border rounded p-1">
                  <option value="">デフォルト</option>
                </select>
              </div>
            </div>
          </div>

          {/* 検索結果一覧テーブル */}
          <Layout.EditableGrid
            getColumnDefs={getColumnDefs}
            rows={searchResults}
            isReadOnly
          />

          {/* ページネーション */}
          <div className="p-2 bg-gray-100 flex justify-center">
            <div className="flex gap-1">
              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(1)}
                disabled={currentPage === 1}
              >
                最初
              </button>
              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(currentPage - 1)}
                disabled={currentPage === 1}
              >
                前へ
              </button>

              {/* ページ番号表示 */}
              <div className="flex">
                {Array.from({ length: Math.min(5, Math.ceil(totalCount / itemsPerPage)) }, (_, i) => {
                  const pageNum = i + 1;
                  return (
                    <button
                      key={i}
                      className={`px-3 py-1 ${currentPage === pageNum ? 'bg-blue-500 text-white' : 'bg-white'} border`}
                      onClick={() => handlePageChange(pageNum)}
                    >
                      {pageNum}
                    </button>
                  );
                })}
              </div>

              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(currentPage + 1)}
                disabled={currentPage >= Math.ceil(totalCount / itemsPerPage)}
              >
                次へ
              </button>
              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(Math.ceil(totalCount / itemsPerPage))}
                disabled={currentPage >= Math.ceil(totalCount / itemsPerPage)}
              >
                最後
              </button>
            </div>
          </div>
        </Panel>
      </PanelGroup>

    </Layout.PageFrame>
  )
}
