import * as React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Input from "../../input"
import * as Layout from "../../layout"
import * as AutoGenerated from "../../__autoGenerated/売上分析"
import * as 店舗マスタAutoGenerated from "../../__autoGenerated/店舗マスタ"
import * as カテゴリマスタAutoGenerated from "../../__autoGenerated/カテゴリマスタ"
import * as 商品マスタAutoGenerated from "../../__autoGenerated/商品マスタ"
import { useParams, useNavigate } from "react-router-dom"
import useEvent from "react-use-event-hook"
// import { useDataSelectorDialog } from "../../parts/DataSelectorDialog" // 未実装

/**
 * 売上分析データ1件の詳細を閲覧・編集する画面。
 * TODO: 売上分析データは通常、集計結果であり編集するものではない可能性が高い。
 *       この画面の要件（特に編集機能）を再確認する必要がある。
 *       一旦は他のマスタ画面に合わせた編集画面として実装する。
 */
export const 売上分析詳細編集画面 = () => {
  const { id } = useParams<{ id: string }>() // id は年月と店舗IDの複合キーかもしれないが、一旦単一IDと仮定
  const navigate = useNavigate()
  const isNew = id === "new" // 新規作成の概念があるかも要確認

  const [isLoading, setIsLoading] = React.useState<boolean>(true)
  const [errorMessage, setErrorMessage] = React.useState<string | null>(null)

  const methods = ReactHookForm.useForm<AutoGenerated.売上分析DisplayData>()
  const {
    control, handleSubmit, reset, setValue, watch, register,
    formState: { errors }
  } = methods

  // --- Row Selection States for Grids ---
  const [カテゴリ別売上RowSelection, setカテゴリ別売上RowSelection] = React.useState<Record<string, boolean>>({});
  const [時間帯別売上RowSelection, set時間帯別売上RowSelection] = React.useState<Record<string, boolean>>({});
  // 商品別売上GridのRowSelectionはカテゴリ別Grid内で管理する必要がある

  // --- Field Arrays ---
  const { fields: カテゴリ別売上Fields, update: updateカテゴリ別売上, append: appendカテゴリ別売上, remove: removeカテゴリ別売上 } =
    ReactHookForm.useFieldArray({ control, name: "カテゴリ別売上" });
  const { fields: 時間帯別売上Fields, update: update時間帯別売上, append: append時間帯別売上, remove: remove時間帯別売上 } =
    ReactHookForm.useFieldArray({ control, name: "時間帯別売上" });
  // 商品別売上FieldArrayはカテゴリ別Grid内で管理

  // --- Data Selector Dialogs (未実装のためコメントアウト) ---
  // const { showDialog: show店舗Dialog, dialogElement: 店舗Dialog } = useDataSelectorDialog<店舗マスタAutoGenerated.店舗マスタRefTarget>(...);
  // const { showDialog: showカテゴリDialog, dialogElement: カテゴリDialog } = useDataSelectorDialog<カテゴリマスタAutoGenerated.カテゴリマスタRefTarget>(...);
  // const { showDialog: show商品Dialog, dialogElement: 商品Dialog } = useDataSelectorDialog<商品マスタAutoGenerated.商品マスタRefTarget>(...);

  // --- Data Fetching ---
  React.useEffect(() => {
    const fetchData = async () => {
      setErrorMessage(null)
      setIsLoading(true);
      let initialData = AutoGenerated.createNew売上分析DisplayData(); // 空データで初期化

      if (!isNew && id) {
        try {
          // TODO: 売上分析のAPIエンドポイントは `/api/売上分析/{id}` ではない可能性が高い
          //       適切なエンドポイントとID形式を確認する必要がある
          const response = await fetch(`/api/売上分析/${id}`) // 仮のエンドポイント
          if (!response.ok) {
            if (response.status === 404) setErrorMessage("指定された売上分析データが見つかりません。")
            else setErrorMessage(`データの取得に失敗しました。(ステータス: ${response.status})`)
          } else {
            initialData = await response.json();
          }
        } catch (error) {
          console.error("データ取得エラー:", error)
          setErrorMessage("データの取得中に予期せぬエラーが発生しました。")
        }
      }
      // ネストされた配列の初期値保証
      if (!initialData.カテゴリ別売上) initialData.カテゴリ別売上 = [];
      initialData.カテゴリ別売上.forEach(cat => {
        if (!cat.商品別売上) cat.商品別売上 = [];
      });
      if (!initialData.時間帯別売上) initialData.時間帯別売上 = [];

      reset(initialData);
      setIsLoading(false);
    }
    fetchData()
  }, [id, isNew, reset])

  // --- Submit Handler ---
  const onSubmit = useEvent(async (data: AutoGenerated.売上分析DisplayData) => {
    setErrorMessage(null)
    setIsLoading(true);
    try {
      // TODO: 売上分析データの保存APIが存在するか、存在する場合の仕様を確認する必要がある
      const method = isNew ? "POST" : "PUT" // 仮
      const url = isNew ? "/api/売上分析" : `/api/売上分析/${id}` // 仮
      const body = JSON.stringify(data);

      const response = await fetch(url, {
        method,
        headers: { "Content-Type": "application/json" },
        body: body,
      })
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        const message = errorData.message || `保存に失敗しました。(ステータス: ${response.status})`
        setErrorMessage(message)
        console.error("保存エラー:", errorData)
        throw new Error(message)
      }
      navigate("/売上分析") // 仮に一覧画面のパスを /売上分析 とする
    } catch (error) {
      console.error("保存処理エラー:", error)
      if (!errorMessage) setErrorMessage("保存中に予期せぬエラーが発生しました。")
    } finally {
      setIsLoading(false);
    }
  })

  // --- Editable Grid Refs ---
  const カテゴリ別売上GridRef = React.useRef<Layout.EditableGridRef<ReactHookForm.FieldArrayWithId<AutoGenerated.売上分析DisplayData, "カテゴリ別売上", "id">>>(null);
  const 時間帯別売上GridRef = React.useRef<Layout.EditableGridRef<ReactHookForm.FieldArrayWithId<AutoGenerated.売上分析DisplayData, "時間帯別売上", "id">>>(null);

  // --- Column Defs ---
  const getカテゴリ別売上ColumnDefs: Layout.GetColumnDefsFunction<ReactHookForm.FieldArrayWithId<AutoGenerated.売上分析DisplayData, "カテゴリ別売上", "id">> = React.useCallback(cellType => [
    // cellType.reference("values.カテゴリ", "カテゴリ", { fetchPath: "/api/カテゴリマスタ", getDisplayValue: item => item.カテゴリ名, editable: true, required: true }), // Dialog未実装
    cellType.text("values.カテゴリ.カテゴリID", "カテゴリID", { editable: true, required: true }), // 代替
    cellType.number("values.売上金額", "売上金額", { editable: true }),
    cellType.number("values.売上構成比", "構成比(%)", { editable: true }), // 表示調整
    cellType.number("values.前年同月比", "前年比(%)", { editable: true }), // 表示調整
    // 商品別売上はサブGridで表示 (Layout.EditableGridがsubGrid未対応のためコメントアウト)
    /*
    cellType.subGrid("商品別売上", "商品別売上", {
        SubGridComponent: 商品別売上Grid, // 下で定義するサブコンポーネント
        parentRowSelectionState: カテゴリ別売上RowSelection, // サブGridの制御用に渡す
        setParentRowSelectionState: setカテゴリ別売上RowSelection, // サブGridの制御用に渡す
    }),
    */
  ], []); // RowSelectionStateがないため依存配列から削除

  const get時間帯別売上ColumnDefs: Layout.GetColumnDefsFunction<ReactHookForm.FieldArrayWithId<AutoGenerated.売上分析DisplayData, "時間帯別売上", "id">> = React.useCallback(cellType => [
    cellType.text("values.時間帯", "時間帯", { editable: true }), // TimeInputなどがないためTextで代用
    cellType.number("values.売上金額", "売上金額", { editable: true }),
    cellType.number("values.売上件数", "売上件数", { editable: true }),
    cellType.number("values.平均客単価", "平均客単価", { editable: true }),
  ], []);


  return (
    <Layout.PageFrame
      headerContent={(
        <>
          {/* 売上分析画面では保存・キャンセルボタンが適切か要検討 */}
          <Input.IconButton fill onClick={(e) => { if (!isLoading) handleSubmit(onSubmit)(e); }}>保存</Input.IconButton>
          <Input.IconButton fill onClick={() => { if (!isLoading) navigate(-1); }}>キャンセル</Input.IconButton>
        </>
      )}
    >
      {isLoading ? (
        <div className="flex justify-center items-center h-64">読み込み中...</div>
      ) : errorMessage ? (
        <div className="m-4 p-4 border border-red-400 bg-red-100 text-red-700 rounded">
          <p>エラー: {errorMessage}</p>
          <button onClick={() => navigate(-1)} className="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-700">戻る</button>
        </div>
      ) : (
        <ReactHookForm.FormProvider {...methods}>
          <Layout.VForm3.Root>
            {/* --- 基本情報 --- */}
            <Layout.VForm3.BreakPoint>
              <Layout.VForm3.Item label="年月" required={AutoGenerated.売上分析Constraints.values.年月.required}>
                <Input.Word name="values.年月" control={control} readOnly={!isNew} /* DateInput(Month) がないためWordで代用 */
                  rules={{ required: "必須", maxLength: { value: 7, message: "YYYY-MM形式" }, pattern: { value: /^\d{4}-\d{2}$/, message: "YYYY-MM形式" } }} />
              </Layout.VForm3.Item>
              <Layout.VForm3.Item label="店舗" required={AutoGenerated.売上分析Constraints.values.店舗.required}>
                {/* DataSelectorDialog未実装のため、WordでID直接入力 */}
                <Input.Word name="values.店舗.店舗ID" control={control} rules={{ required: "必須" }} />
                {/* <Input.IconButton disabled>検索</Input.IconButton> */}
              </Layout.VForm3.Item>
              <Layout.VForm3.Item label="売上合計" required={AutoGenerated.売上分析Constraints.values.売上合計.required}>
                <Input.NumberInput name="values.売上合計" control={control} readOnly /* 計算結果のはずなのでReadOnly */
                  rules={{ required: "必須", min: 0 }} />
              </Layout.VForm3.Item>
              <Layout.VForm3.Item label="客数" required={AutoGenerated.売上分析Constraints.values.客数.required}>
                <Input.NumberInput name="values.客数" control={control} readOnly /* 計算結果のはずなのでReadOnly */
                  rules={{ required: "必須", min: 0 }} />
              </Layout.VForm3.Item>
              <Layout.VForm3.Item label="客単価" required={AutoGenerated.売上分析Constraints.values.客単価.required}>
                <Input.NumberInput name="values.客単価" control={control} readOnly /* 計算結果のはずなのでReadOnly */
                  rules={{ required: "必須", min: 0 }} />
              </Layout.VForm3.Item>
              <Layout.VForm3.Item label="目標達成率(%)" required={AutoGenerated.売上分析Constraints.values.目標達成率.required}>
                <Input.NumberInput name="values.目標達成率" control={control} readOnly /* 計算結果のはずなのでReadOnly */
                  rules={{ required: "必須" }} />
              </Layout.VForm3.Item>
            </Layout.VForm3.BreakPoint>

            {/* --- カテゴリ別売上 (Editable Grid) --- */}
            <Layout.VForm3.FullWidthItem label={(
              <div className="flex flex-row items-center">
                <div>カテゴリ別売上</div>
                <div className="basis-4"></div>
                {/* 通常、分析結果の行追加/削除はしないはず */}
                {/* <Input.IconButton fill onClick={() => appendカテゴリ別売上(AutoGenerated.createNewカテゴリ別売上DisplayData())}>追加</Input.IconButton>
                                <Input.IconButton fill onClick={() => {
                                    const selected = カテゴリ別売上GridRef.current?.getSelectedRows();
                                    if (selected) removeカテゴリ別売上(selected.map(r => r.rowIndex));
                                }}>削除</Input.IconButton> */}
              </div>
            )}>
              <Layout.EditableGrid
                ref={カテゴリ別売上GridRef}
                rows={カテゴリ別売上Fields}
                getColumnDefs={getカテゴリ別売上ColumnDefs}
                rowSelection={カテゴリ別売上RowSelection} // サブGridを含む場合は必須
                onRowSelectionChange={setカテゴリ別売上RowSelection} // サブGridを含む場合は必須
                onChangeRow={e => {
                  for (const x of e.changedRows) {
                    updateカテゴリ別売上(x.rowIndex, x.newRow)
                  }
                }}
              />
            </Layout.VForm3.FullWidthItem>

            {/* --- 時間帯別売上 (Editable Grid) --- */}
            <Layout.VForm3.FullWidthItem label={(
              <div className="flex flex-row items-center">
                <div>時間帯別売上</div>
                <div className="basis-4"></div>
                {/* 通常、分析結果の行追加/削除はしないはず */}
                {/* <Input.IconButton fill onClick={() => append時間帯別売上(AutoGenerated.createNew時間帯別売上DisplayData())}>追加</Input.IconButton>
                                <Input.IconButton fill onClick={() => {
                                    const selected = 時間帯別売上GridRef.current?.getSelectedRows();
                                    if (selected) remove時間帯別売上(selected.map(r => r.rowIndex));
                                }}>削除</Input.IconButton> */}
              </div>
            )}>
              <Layout.EditableGrid
                ref={時間帯別売上GridRef}
                rows={時間帯別売上Fields}
                getColumnDefs={get時間帯別売上ColumnDefs}
                rowSelection={時間帯別売上RowSelection}
                onRowSelectionChange={set時間帯別売上RowSelection}
                onChangeRow={e => {
                  for (const x of e.changedRows) {
                    update時間帯別売上(x.rowIndex, x.newRow)
                  }
                }}
              />
            </Layout.VForm3.FullWidthItem>

          </Layout.VForm3.Root>
        </ReactHookForm.FormProvider>
      )}
      {/* ダイアログ要素 (未実装) */}
    </Layout.PageFrame>
  )
}


// --- 商品別売上Grid (サブコンポーネント) ---
// Layout.SubGridComponentProps が未定義のため、関連Propsをコメントアウト
interface 商品別売上GridProps /* extends Layout.SubGridComponentProps<AutoGenerated.カテゴリ別売上DisplayData> */ {
  parentRowIndex: number; // 親Gridの行インデックスは必要
  control: ReactHookForm.Control<AutoGenerated.売上分析DisplayData>; // form制御用
  // 以下はsubGrid機能がないため不要
  // parentRowSelectionState: Record<string, boolean>;
  // setParentRowSelectionState: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
}
const 商品別売上Grid: React.FC<商品別売上GridProps> = ({
  parentRowIndex,
  control,
  // parentRowSelectionState,
  // setParentRowSelectionState
}) => {
  const namePrefix = `カテゴリ別売上.${parentRowIndex}.商品別売上` as const;
  const { fields, update, append, remove } = ReactHookForm.useFieldArray({
    control,
    name: namePrefix
  });
  const gridRef = React.useRef<Layout.EditableGridRef<ReactHookForm.FieldArrayWithId<AutoGenerated.カテゴリ別売上DisplayData, "商品別売上", "id">>>(null);

  // サブGrid用のRowSelection管理 (ローカルで管理)
  const [商品別売上RowSelection, set商品別売上RowSelection] = React.useState<Record<string, boolean>>({});

  const getColumnDefs: Layout.GetColumnDefsFunction<ReactHookForm.FieldArrayWithId<AutoGenerated.カテゴリ別売上DisplayData, "商品別売上", "id">> = React.useCallback(cellType => [
    // cellType.reference("values.商品", "商品", { fetchPath: "/api/商品マスタ", getDisplayValue: item => item.商品名, editable: true, required: true }), // Dialog未実装
    cellType.text("values.商品.ID", "商品ID", { editable: true, required: true }), // 代替
    cellType.number("values.売上金額", "売上金額", { editable: true }),
    cellType.number("values.売上数量", "売上数量", { editable: true }),
    cellType.number("values.平均単価", "平均単価", { editable: true, isReadOnly: true }), // 計算結果のはず
  ], []);

  return (
    <div className="pl-4 border-l ml-4"> {/* インデント */}
      <div className="flex flex-row items-center mb-1 text-sm"> {/* 少し小さく */}
        <div>商品別売上</div>
        <div className="basis-2"></div>
        {/* 通常、分析結果の行追加/削除はしないはず */}
        {/* <Input.IconButton size="sm" fill onClick={() => append(AutoGenerated.createNew商品別売上DisplayData())}>追加</Input.IconButton>
                <Input.IconButton size="sm" fill onClick={() => {
                    const selected = gridRef.current?.getSelectedRows();
                    if (selected) remove(selected.map(r => r.rowIndex));
                }}>削除</Input.IconButton> */}
      </div>
      <Layout.EditableGrid
        ref={gridRef}
        rows={fields}
        getColumnDefs={getColumnDefs}
        rowSelection={商品別売上RowSelection} // ローカル状態を渡す
        onRowSelectionChange={set商品別売上RowSelection} // ローカル状態セッターを渡す
        onChangeRow={e => {
          for (const x of e.changedRows) {
            update(x.rowIndex, x.newRow)
          }
        }}
      />
    </div>
  );
};
