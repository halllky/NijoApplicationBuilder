import { FieldErrors, UseFormReturn, useForm } from "react-hook-form"
import { DisplayDataTypeMap, LoadFeature, QueryModelType, SearchConditionTypeMap, createNewSearchConditionFunctions } from "../__autoGenerated"
import { ColumnDef, ColumnDefFactories, useCellTypes } from "./cellType"
import React, { useCallback, useEffect, useMemo, useState } from "react"
import { Panel, PanelGroup, PanelResizeHandle } from "react-resizable-panels"
import * as Util from "../util"

/**
 * QueryModelのルート集約の一覧検索画面。
 *
 * ## 画面構成
 * - 画面ヘッダ部
 *   - 画面タイトル（呼び出し側で指定する）
 *   - クリアボタン
 *     - 検索条件欄の内容を画面初期表示時のものにリセットする。
 *   - 検索ボタン
 *     - 現在入力されている内容で検索を実行する。検索処理のReactフックは自動生成されたものを使用する。
 *     - 検索ボタンの「▽」をクリックすると、画面上部の検索条件欄を折り畳みまたは展開できる。
 * - 画面上部
 *   - 検索条件欄。呼び出し側で指定する。
 * - 画面上部と下部の境界部分
 *   - 検索結果件数の総数
 *   - 1ページあたりの表示件数（ドロップダウンで指定可能）
 *   - 並び順（MultiSelectで指定可能）
 *   - 境界部分をドラッグして、画面上部のサイズを変更できる。（react-resizable-panelsを使用）
 * - 画面下部
 *   - 検索結果一覧。列定義を呼び出し側で指定する。
 *   - ページネーションは自動的に表示される。
 */
export const MultiView = <TQueryModel extends QueryModelType>(
  props: MultiViewProps<TQueryModel>,
) => {
  const { queryModel, isReady, title, children, initialSearchCondition, getColumnDefs } = props

  // 検索条件用のreact-hook-form
  const defaultValues = useMemo(() => initialSearchCondition || createNewSearchConditionFunctions[queryModel](), [initialSearchCondition, queryModel])
  const reactHookFormMethods = useForm<SearchConditionTypeMap[TQueryModel]>({
    defaultValues: defaultValues as any,
  })
  const { reset, handleSubmit } = reactHookFormMethods

  // 検索条件パネルの折りたたみ状態
  const [isSearchConditionCollapsed, setIsSearchConditionCollapsed] = useState(false)

  // ページネーション関連の状態
  const [currentPage, setCurrentPage] = useState(1)
  const [itemsPerPage, setItemsPerPage] = useState(10)
  const [totalCount, setTotalCount] = useState(0)

  // 検索結果
  const [searchResults, setSearchResults] = useState<DisplayDataTypeMap[TQueryModel][]>([])

  // 検索中の状態
  const [isSearching, setIsSearching] = useState(false)

  // 列定義
  const cellType = useCellTypes<DisplayDataTypeMap[TQueryModel]>()
  const columnDefs = useMemo(() => getColumnDefs(cellType), [getColumnDefs, cellType])

  // テスト用の列定義を生成する関数 (テストのために使用)
  const generateMockColumnDefs = () => {
    const mockColumnDefs: ColumnDef<DisplayDataTypeMap[TQueryModel]>[] = columnDefs.map(def => {
      return {
        ...def,
        fieldPath: typeof def.fieldPath === 'string' ? def.fieldPath : def.header
      };
    });
    return mockColumnDefs;
  }

  // 実際に使用する列定義
  const finalColumnDefs = useMemo(() => generateMockColumnDefs(), [columnDefs]);

  // 検索実行関数
  const { complexPost } = Util.useHttpRequest()
  const doSearch = useCallback(async (data: SearchConditionTypeMap[TQueryModel]) => {
    try {
      setIsSearching(true)
      // ページネーション情報を設定
      const searchData = { ...data }
      searchData.skip = (currentPage - 1) * itemsPerPage
      searchData.take = itemsPerPage

      // APIを呼び出す
      reactHookFormMethods.clearErrors()
      const response = await complexPost<LoadFeature.ReturnType[TQueryModel]>(LoadFeature.Endpoint[queryModel], searchData, {
        handleDetailMessage: (detail) => Util.setErrorDetailMessage(reactHookFormMethods.setError, detail),
      })

      setSearchResults(response?.currentPageItems ?? [])
      setTotalCount(response?.totalCount ?? 0)

    } catch (error) {
      console.error('検索中にエラーが発生しました:', error)
      // エラー時は空の結果を設定
      setSearchResults([])
      setTotalCount(0)
    } finally {
      setIsSearching(false)
    }
  }, [currentPage, itemsPerPage, queryModel, complexPost])

  // 初期検索実行
  useEffect(() => {
    if (isReady) {
      handleSubmit(doSearch)()
    }
  }, [isReady, handleSubmit, doSearch])

  // ページ変更時の処理
  useEffect(() => {
    if (isReady) {
      handleSubmit(doSearch)()
    }
  }, [currentPage, itemsPerPage])

  // クリアボタンのハンドラ
  const handleClear = useCallback(() => {
    reset(defaultValues as any)
  }, [reset, defaultValues])

  // ページ変更ハンドラー
  const handlePageChange = useCallback((page: number) => {
    setCurrentPage(page)
  }, [])

  // 1ページあたりの表示件数変更ハンドラー
  const handleItemsPerPageChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setItemsPerPage(Number(e.target.value))
    setCurrentPage(1) // ページ数が変わったら1ページ目に戻る
  }, [])

  return (
    <div className="flex flex-col h-full">
      {/* 画面ヘッダ部 */}
      <div className="p-4 border-b flex justify-between items-center">
        <h1 className="text-xl font-bold">{title || `${queryModel}一覧検索`}</h1>
        <div className="flex gap-2">
          <button
            className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300"
            onClick={handleClear}
          >
            クリア
          </button>
          <div className="flex">
            <button
              className="px-3 py-1 bg-blue-500 text-white rounded-l hover:bg-blue-600"
              onClick={handleSubmit(doSearch)}
              disabled={isSearching}
            >
              検索
            </button>
            <button
              className="px-1 py-1 bg-blue-500 text-white rounded-r hover:bg-blue-600 border-l border-blue-400"
              onClick={() => setIsSearchConditionCollapsed(!isSearchConditionCollapsed)}
            >
              {isSearchConditionCollapsed ? '△' : '▽'}
            </button>
          </div>
        </div>
      </div>

      <PanelGroup direction="vertical" className="flex-grow">
        {/* 画面上部: 検索条件欄 */}
        {!isSearchConditionCollapsed && (
          <Panel defaultSize={30} minSize={10}>
            <div className="p-4 overflow-auto h-full">
              {children && children({ reactHookFormMethods })}
            </div>
          </Panel>
        )}

        {!isSearchConditionCollapsed && (
          <PanelResizeHandle className="h-2 bg-gray-200 hover:bg-gray-300 cursor-row-resize flex items-center justify-center">
            <div className="w-8 h-1 bg-gray-400 rounded"></div>
          </PanelResizeHandle>
        )}

        {/* 画面下部: 検索結果一覧 */}
        <Panel>
          <div className="flex flex-col h-full">
            {/* 境界部分 */}
            <div className="p-2 bg-gray-100 flex justify-between items-center">
              <div>
                検索結果: <span className="font-bold">{totalCount}</span> 件
              </div>
              <div className="flex items-center gap-4">
                <div className="flex items-center">
                  <label className="mr-2">表示件数:</label>
                  <select
                    value={itemsPerPage}
                    onChange={handleItemsPerPageChange}
                    className="border rounded p-1"
                  >
                    <option value="5">5件</option>
                    <option value="10">10件</option>
                    <option value="20">20件</option>
                    <option value="50">50件</option>
                  </select>
                </div>
                <div className="flex items-center">
                  <label className="mr-2">並び順:</label>
                  <select className="border rounded p-1">
                    <option value="">デフォルト</option>
                  </select>
                </div>
              </div>
            </div>

            {/* 検索結果一覧テーブル */}
            <div className="flex-grow overflow-auto p-2">
              <table className="w-full border-collapse">
                <thead>
                  <tr className="bg-gray-50">
                    {finalColumnDefs.map((column, index) => (
                      <th key={index} className="border p-2 text-left">
                        {column.header}
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {isSearching ? (
                    <tr>
                      <td colSpan={finalColumnDefs.length} className="text-center p-4">
                        検索中...
                      </td>
                    </tr>
                  ) : searchResults.length === 0 ? (
                    <tr>
                      <td colSpan={finalColumnDefs.length} className="text-center p-4">
                        検索結果がありません
                      </td>
                    </tr>
                  ) : (
                    searchResults.map((row, rowIndex) => (
                      <tr key={rowIndex} className="border-b hover:bg-gray-50">
                        {finalColumnDefs.map((column, colIndex) => {
                          const fieldPath = column.fieldPath || '';
                          // パスからデータを取得
                          let value: any = row;
                          const pathParts = fieldPath.split('.');
                          for (const part of pathParts) {
                            value = value?.[part];
                          }

                          return (
                            <td key={colIndex} className="border p-2">
                              {String(value || '')}
                            </td>
                          );
                        })}
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>

            {/* ページネーション */}
            <div className="p-2 bg-gray-100 flex justify-center">
              <div className="flex gap-1">
                <button
                  className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                  onClick={() => handlePageChange(1)}
                  disabled={currentPage === 1}
                >
                  最初
                </button>
                <button
                  className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                  onClick={() => handlePageChange(currentPage - 1)}
                  disabled={currentPage === 1}
                >
                  前へ
                </button>

                {/* ページ番号表示 */}
                <div className="flex">
                  {Array.from({ length: Math.min(5, Math.ceil(totalCount / itemsPerPage)) }, (_, i) => {
                    const pageNum = i + 1;
                    return (
                      <button
                        key={i}
                        className={`px-3 py-1 ${currentPage === pageNum ? 'bg-blue-500 text-white' : 'bg-white'} border`}
                        onClick={() => handlePageChange(pageNum)}
                      >
                        {pageNum}
                      </button>
                    );
                  })}
                </div>

                <button
                  className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                  onClick={() => handlePageChange(currentPage + 1)}
                  disabled={currentPage >= Math.ceil(totalCount / itemsPerPage)}
                >
                  次へ
                </button>
                <button
                  className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                  onClick={() => handlePageChange(Math.ceil(totalCount / itemsPerPage))}
                  disabled={currentPage >= Math.ceil(totalCount / itemsPerPage)}
                >
                  最後
                </button>
              </div>
            </div>
          </div>
        </Panel>
      </PanelGroup>
    </div>
  )
}

export type MultiViewProps<TQueryModelType extends QueryModelType> = {
  /** QueryModelの種類 */
  queryModel: TQueryModelType
  /**
   * この値がtrueになると初期表示処理等が開始される。
   * 例えば、検索条件欄の初期値にログインユーザーの情報が必要で、
   * ログインユーザー情報はサーバー側から非同期で取得してくるといった場合、
   * ログインユーザー情報取得完了まではこの値をfalseにしておく。
   */
  isReady: boolean
  /** 画面タイトル */
  title?: string
  /** 画面上部の検索条件欄 */
  children?: (props: {
    /** 画面の検索条件を管理するReact Hook Formのメソッド。 */
    reactHookFormMethods: UseFormReturn<SearchConditionTypeMap[TQueryModelType]>
  }) => React.ReactNode
  /**
   * 画面初期表示時の検索条件。
   * 挙動を安定させるために `useMemo` でラップした値を使用すること。
   */
  initialSearchCondition?: SearchConditionTypeMap[TQueryModelType]
  /**
   * 列を定義する関数。
   * この関数の参照が変わる度に検索結果グリッドが再レンダリングされるため、
   * 原則として `useCallback` を使用すること。
   * @param cellType セル型定義ヘルパー関数の一覧。
   */
  getColumnDefs: (cellType: ColumnDefFactories<DisplayDataTypeMap[TQueryModelType]>) => ColumnDef<DisplayDataTypeMap[TQueryModelType]>[]
}
