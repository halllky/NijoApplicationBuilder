import { UseFormReturn, useForm, FormProvider } from "react-hook-form"
import { DisplayDataTypeMap, LoadFeature, QueryModelType, SearchConditionTypeMap, createNewSearchConditionFunctions } from "../__autoGenerated"
import { GetColumnDefsFunction } from "./EditableGrid/index.d"
import { useCellTypes } from "./EditableGrid/useCellTypes"
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react"
import { Panel, PanelGroup, PanelResizeHandle, ImperativePanelGroupHandle } from "react-resizable-panels"
import * as Util from "../util"
import { PageFrame, PageFrameTitle } from "./PageFrame"

/**
 * QueryModelのルート集約の一覧検索画面。
 *
 * ## 画面構成
 * - 画面ヘッダ部
 *   - 画面タイトル（呼び出し側で指定する）
 *   - クリアボタン
 *     - 検索条件欄の内容を画面初期表示時のものにリセットする。
 *   - 検索ボタン
 *     - 現在入力されている内容で検索を実行する。検索処理のReactフックは自動生成されたものを使用する。
 *     - 検索ボタンの「▽」をクリックすると、画面上部の検索条件欄を折り畳みまたは展開できる。
 * - 画面上部
 *   - 検索条件欄。呼び出し側で指定する。
 * - 画面上部と下部の境界部分
 *   - 検索結果件数の総数
 *   - 1ページあたりの表示件数（ドロップダウンで指定可能）
 *   - 並び順（MultiSelectで指定可能）
 *   - 境界部分をドラッグして、画面上部のサイズを変更できる。（react-resizable-panelsを使用）
 * - 画面下部
 *   - 検索結果一覧。列定義を呼び出し側で指定する。
 *   - ページネーションは自動的に表示される。
 */
export const MultiView = <TQueryModel extends QueryModelType>(
  props: MultiViewProps<TQueryModel>,
) => {
  const { queryModel, isReady, title, children, initialSearchCondition, getColumnDefs, headerButtons } = props

  // 検索条件用のreact-hook-form
  const defaultValues = useMemo(() => initialSearchCondition || createNewSearchConditionFunctions[queryModel](), [initialSearchCondition, queryModel])
  const reactHookFormMethods = useForm<SearchConditionTypeMap[TQueryModel]>({
    defaultValues: defaultValues as any,
  })
  const { reset, handleSubmit } = reactHookFormMethods

  // PanelGroup の Ref
  const groupRef = useRef<ImperativePanelGroupHandle>(null)
  // 上部パネルが閉じているかどうかの状態 (ボタン表示用)
  const [isTopPanelCollapsed, setIsTopPanelCollapsed] = useState(false)

  // ページネーション関連の状態
  const [currentPage, setCurrentPage] = useState(1)
  const [itemsPerPage, setItemsPerPage] = useState(10)
  const [totalCount, setTotalCount] = useState(0)

  // 検索結果
  const [searchResults, setSearchResults] = useState<DisplayDataTypeMap[TQueryModel][]>([])

  // 検索中の状態
  const [isSearching, setIsSearching] = useState(false)

  // 列定義
  const cellType = useCellTypes<DisplayDataTypeMap[TQueryModel]>()
  const columnDefs = useMemo(() => getColumnDefs(cellType), [getColumnDefs, cellType])

  // 検索実行関数
  const { complexPost } = Util.useHttpRequest()
  const doSearch = useCallback(async (data: SearchConditionTypeMap[TQueryModel]) => {
    try {
      setIsSearching(true)

      // 検索用パラメータの構築
      const searchData = {
        condition: data,
        pageSize: itemsPerPage,
        pageNo: currentPage
      }

      console.log('search data:', searchData)

      // 検索APIの呼び出し
      const response = await complexPost<{ currentPageItems: DisplayDataTypeMap[TQueryModel][], totalCount: number }>(
        LoadFeature.Endpoint[queryModel],
        searchData
      )

      console.log('API response type:', typeof response)
      console.log('API response:', response)

      // レスポンスが文字列の場合、JSONとして解析
      let parsedResponse = response;
      if (typeof response === 'string') {
        try {
          parsedResponse = JSON.parse(response);
          console.log('API responseをパース後:', parsedResponse);
        } catch (error) {
          console.error('JSON解析エラー:', error);
        }
      }

      // 解析されたレスポンスを使用
      if (parsedResponse && parsedResponse.currentPageItems) {
        setSearchResults(parsedResponse.currentPageItems)
        setTotalCount(parsedResponse.totalCount || 0)
      } else {
        console.log('検索結果なし')
        setSearchResults([])
        setTotalCount(0)
      }
    } catch (e) {
      console.error(e)
      setSearchResults([])
      setTotalCount(0)
    } finally {
      setIsSearching(false)
    }
  }, [currentPage, itemsPerPage, queryModel, complexPost])

  // 初期検索実行
  useEffect(() => {
    if (isReady) {
      handleSubmit(doSearch)()
    }
  }, [isReady, handleSubmit, doSearch])

  // ページ変更時の処理
  useEffect(() => {
    if (isReady) {
      handleSubmit(doSearch)()
    }
  }, [currentPage, itemsPerPage])

  // クリアボタンのハンドラ
  const handleClear = useCallback(() => {
    reset(defaultValues as any)
  }, [reset, defaultValues])

  // ページ変更ハンドラー
  const handlePageChange = useCallback((page: number) => {
    setCurrentPage(page)
  }, [])

  // 1ページあたりの表示件数変更ハンドラー
  const handleItemsPerPageChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setItemsPerPage(Number(e.target.value))
    setCurrentPage(1) // ページ数が変わったら1ページ目に戻る
  }, [])

  // パネルの開閉を切り替える関数
  const toggleSearchConditionPanel = useCallback(() => {
    const group = groupRef.current;
    if (!group) return;

    const currentLayout = group.getLayout(); // 現在のレイアウトを取得 (パーセンテージ)
    if (currentLayout.length < 2) return; // 予期しないレイアウトの場合は何もしない

    // 現在折りたたまれているか (最初のパネルのサイズが0か)
    const isCurrentlyCollapsed = currentLayout[0] < 1; // 完全に0でなくても小さい場合は畳まれているとみなす

    const newLayout = isCurrentlyCollapsed
      ? [30, 70] // 展開する (例: 上部30%)
      : [0, 100]; // 折りたたむ (上部0%)

    group.setLayout(newLayout);
  }, []);

  return (
    <PageFrame headerContent={(<>
      <PageFrameTitle>
        {title || `${queryModel}一覧検索`}
      </PageFrameTitle>
      <div className="flex-1"></div>
      {headerButtons}
      <button onClick={handleClear} className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 mx-2">
        クリア
      </button>
      <div className="flex">
        <button
          className="px-3 py-1 bg-blue-500 text-white rounded-l hover:bg-blue-600"
          onClick={handleSubmit(doSearch)}
          disabled={isSearching}
        >
          検索
        </button>
        <button
          className="px-2 py-1 bg-blue-500 text-white rounded-r hover:bg-blue-600 border-l border-blue-400"
          onClick={toggleSearchConditionPanel}
        >
          {isTopPanelCollapsed ? '△' : '▽'}
        </button>
      </div>
    </>)}>

      <PanelGroup direction="vertical" ref={groupRef}>
        {/* 画面上部: 検索条件欄 */}
        <Panel
          defaultSize={30}
          minSize={10}
          collapsible
          collapsedSize={0}
          order={1}
          onCollapse={() => setIsTopPanelCollapsed(true)}
          onExpand={() => setIsTopPanelCollapsed(false)}
        >
          <div className="p-1 overflow-auto h-full">
            <FormProvider {...reactHookFormMethods}>
              {children?.({ reactHookFormMethods })}
            </FormProvider>
          </div>
        </Panel>

        <PanelResizeHandle className="h-2 bg-gray-200 hover:bg-gray-300 cursor-row-resize flex items-center justify-center">
          <div className="w-8 h-1 bg-gray-400 rounded"></div>
        </PanelResizeHandle>

        {/* 画面下部: 検索結果一覧 */}
        <Panel order={2} className="flex-1 flex flex-col">
          {/* 境界部分 */}
          <div className="p-1 bg-gray-100 flex justify-between items-center">
            <div>
              検索結果: <span className="font-bold">{totalCount}</span> 件
            </div>
            <div className="flex items-center gap-4">
              <div className="flex items-center">
                <label className="mr-2">表示件数:</label>
                <select
                  value={itemsPerPage}
                  onChange={handleItemsPerPageChange}
                  className="border rounded p-1"
                >
                  <option value="5">5件</option>
                  <option value="10">10件</option>
                  <option value="20">20件</option>
                  <option value="50">50件</option>
                </select>
              </div>
              <div className="flex items-center">
                <label className="mr-2">並び順:</label>
                <select className="border rounded p-1">
                  <option value="">デフォルト</option>
                </select>
              </div>
            </div>
          </div>

          {/* 検索結果一覧テーブル */}
          <div className="flex-1 overflow-auto p-1">
            <table className="w-full border-collapse">
              <thead>
                <tr className="bg-gray-50">
                  {columnDefs.map((column, index) => (
                    <th key={index} className="border p-1 text-left">
                      {column.header}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {isSearching ? (
                  <tr>
                    <td colSpan={columnDefs.length} className="text-center p-4">
                      検索中...
                    </td>
                  </tr>
                ) : searchResults.length === 0 ? (
                  <tr>
                    <td colSpan={columnDefs.length} className="text-center p-4">
                      検索結果がありません
                    </td>
                  </tr>
                ) : (
                  searchResults.map((row, rowIndex) => (
                    <tr key={rowIndex} className="border-b hover:bg-gray-50">
                      {columnDefs.map((column, colIndex) => {
                        const fieldPath = column.fieldPath || '';

                        // パスからデータを取得
                        let value: any = null;

                        try {
                          if (fieldPath.startsWith('住所.values.') && '住所' in row) {
                            // 住所フィールドの特別処理（顧客データの場合）
                            const addressField = fieldPath.split('.')[2]; // '住所.values.都道府県' -> '都道府県'
                            if (row.住所 && row.住所.values) {
                              // 型安全に住所データにアクセス
                              switch (addressField) {
                                case '都道府県':
                                  value = row.住所.values.都道府県;
                                  break;
                                case '市町村':
                                  value = row.住所.values.市町村;
                                  break;
                                case '番地以降':
                                  value = row.住所.values.番地以降;
                                  break;
                                default:
                                  value = null;
                              }
                            }
                          } else {
                            // 通常のフィールド処理
                            value = row;
                            const pathParts = fieldPath.split('.');
                            for (const part of pathParts) {
                              if (value && part in value) {
                                value = value[part];
                              } else {
                                value = null;
                                break;
                              }
                            }
                          }
                        } catch (e) {
                          console.error('データ取得エラー:', e, fieldPath, row);
                          value = null;
                        }

                        return (
                          <td key={colIndex} className="border p-2">
                            {value !== null ? String(value) : ''}
                          </td>
                        );
                      })}
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>

          {/* ページネーション */}
          <div className="p-2 bg-gray-100 flex justify-center">
            <div className="flex gap-1">
              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(1)}
                disabled={currentPage === 1}
              >
                最初
              </button>
              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(currentPage - 1)}
                disabled={currentPage === 1}
              >
                前へ
              </button>

              {/* ページ番号表示 */}
              <div className="flex">
                {Array.from({ length: Math.min(5, Math.ceil(totalCount / itemsPerPage)) }, (_, i) => {
                  const pageNum = i + 1;
                  return (
                    <button
                      key={i}
                      className={`px-3 py-1 ${currentPage === pageNum ? 'bg-blue-500 text-white' : 'bg-white'} border`}
                      onClick={() => handlePageChange(pageNum)}
                    >
                      {pageNum}
                    </button>
                  );
                })}
              </div>

              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(currentPage + 1)}
                disabled={currentPage >= Math.ceil(totalCount / itemsPerPage)}
              >
                次へ
              </button>
              <button
                className="px-3 py-1 rounded border bg-white disabled:opacity-50"
                onClick={() => handlePageChange(Math.ceil(totalCount / itemsPerPage))}
                disabled={currentPage >= Math.ceil(totalCount / itemsPerPage)}
              >
                最後
              </button>
            </div>
          </div>
        </Panel>
      </PanelGroup>

    </PageFrame>
  )
}

export type MultiViewProps<TQueryModelType extends QueryModelType> = {
  /** QueryModelの種類 */
  queryModel: TQueryModelType
  /**
   * この値がtrueになると初期表示処理等が開始される。
   * 例えば、検索条件欄の初期値にログインユーザーの情報が必要で、
   * ログインユーザー情報はサーバー側から非同期で取得してくるといった場合、
   * ログインユーザー情報取得完了まではこの値をfalseにしておく。
   */
  isReady: boolean
  /** 画面タイトル */
  title?: string
  /** 画面上部の検索条件欄 */
  children?: (props: {
    /** 画面の検索条件を管理するReact Hook Formのメソッド。 */
    reactHookFormMethods: UseFormReturn<SearchConditionTypeMap[TQueryModelType]>
  }) => React.ReactNode
  /**
   * 画面初期表示時の検索条件。
   * 挙動を安定させるために `useMemo` でラップした値を使用すること。
   */
  initialSearchCondition?: SearchConditionTypeMap[TQueryModelType]
  /**
   * 列を定義する関数。
   * この関数の参照が変わる度に検索結果グリッドが再レンダリングされるため、
   * 原則として `useCallback` を使用すること。
   * @param cellType セル型定義ヘルパー関数の一覧。
   */
  getColumnDefs: GetColumnDefsFunction<DisplayDataTypeMap[TQueryModelType]>
  /**
   * ヘッダー部に表示する追加ボタン等
   */
  headerButtons?: React.ReactNode
}
