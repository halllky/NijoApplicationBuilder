import React from "react"
import * as ReactHookForm from "react-hook-form"
import * as Icon from "@heroicons/react/24/outline"
import * as Input from "../input"
import * as Layout from "../layout"
import { EditableDbRecord, TableMetadataHelper } from "./types"
import { DataModelMetadata } from "../__autoGenerated/util"
import useQueryEditorServerApi from "./useQueryEditorServerApi"

export const useDbRecordGridColumnDef = (
  mode: 'single-view-children' | 'multi-record-editor',
  tableMetadata: DataModelMetadata.Aggregate,
  tableMetadataHelper: TableMetadataHelper,
  useFieldArrayUpdate: (index: number, value: EditableDbRecord) => void,
) => {
  const [foreignKeyReferenceDialog, setForeignKeyReferenceDialog] = React.useState<ForeignKeyReferenceDialogProps | null>(null)
  const getColumnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    const status = cellType.other('', {
      defaultWidth: 48,
      enableResizing: false,
      isFixed: true,
      isReadOnly: () => true,
      renderCell: cell => (
        <div className="w-full">
          {!cell.row.original.existsInDb ? (
            <span className="text-green-500">
              新規
            </span>
          ) : cell.row.original.deleted ? (
            <span className="text-red-500">
              削除
            </span>
          ) : cell.row.original.changed ? (
            <span className="text-blue-500">
              変更
            </span>
          ) : (
            <span></span>
          )}
        </div>
      ),
    })

    const thisTableMetadata = tableMetadataHelper.allAggregates().find(table => table.tableName === tableMetadata.tableName)
    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []

    for (const column of thisTableMetadata?.members ?? []) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは表示しない
        continue

      }

      if (column.type === "ref-key" || column.type === "own-column" || column.type === "parent-key") {

        // SingleViewの子テーブルの場合は親キーの列は表示しない
        if (mode === 'single-view-children' && column.refToRelationName == null && column.type === "parent-key") {
          continue
        }

        valueColumns.push(cellType.other(column.columnName ?? '', {
          // DBに存在する主キーの列は編集不可。
          isReadOnly: row => row.existsInDb && column.isPrimaryKey,

          onStartEditing: e => {
            e.setEditorInitialValue(e.row.values[column.columnName] ?? '')
          },

          onEndEditing: e => {
            const clone = window.structuredClone(e.row)
            clone.values[column.columnName] = e.value === '' ? null : e.value
            e.setEditedRow(clone)
          },

          renderCell: cell => {
            const isReadOnly = cell.row.original.existsInDb && column.isPrimaryKey

            // 外部キーの列の場合は検索ダイアログから選択できるようにする
            const handleClick = () => {
              const refToAggregate = tableMetadataHelper.getRefTo(column)
              if (!refToAggregate) {
                throw new Error(`外部参照先テーブルが見つかりません: ${column.refToAggregatePath}`)
              }
              setForeignKeyReferenceDialog({
                tableMetadata: refToAggregate,
                onSelect: selectedRecord => {
                  // 複合キーの考慮のため、その相手方を参照するキーの値を全部代入する
                  const clone = window.structuredClone(cell.row.original)
                  for (const m of thisTableMetadata?.members ?? []) {
                    if (m.type !== "ref-key" || m.refToRelationName !== column.refToRelationName) continue;
                    if (!m.refToColumnName) throw new Error(`${m.columnName}の参照先カラムが見つかりません。`) // ありえないが念のため
                    const value = selectedRecord.values[m.refToColumnName]
                    clone.values[m.columnName] = value === '' ? null : value
                  }
                  clone.changed = true
                  useFieldArrayUpdate(cell.row.index, clone)
                  setForeignKeyReferenceDialog(null)
                },
                onCancel: () => setForeignKeyReferenceDialog(null),
              })
            }

            const isNull = cell.row.original.values[column.columnName] === null

            return (
              <div className="w-full flex overflow-hidden px-1">

                {/* 検索ダイアログ展開ボタン */}
                {column.type === "ref-key" && !isReadOnly && (
                  <Input.IconButton icon={Icon.MagnifyingGlassIcon} hideText mini onClick={handleClick}>
                    検索
                  </Input.IconButton>
                )}

                <span className={`flex-1 truncate ${isNull ? 'text-gray-300' : ''}`}>
                  {isNull ? 'NULL' : cell.row.original.values[column.columnName]}
                </span>
              </div>
            )
          },
        }))
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      status,
      ...valueColumns,
    ]
  }, [tableMetadataHelper])

  return {
    /** 列定義 */
    getColumnDefs,

    /** 外部参照テーブルのレコード選択ダイアログ。呼び出し元に配置する必要がある。 */
    ForeignKeyReferenceDialog: (
      foreignKeyReferenceDialog ? (
        <ForeignKeyReferenceDialog
          tableMetadata={foreignKeyReferenceDialog.tableMetadata}
          onSelect={foreignKeyReferenceDialog.onSelect}
          onCancel={foreignKeyReferenceDialog.onCancel}
        />
      ) : null
    ),
  }
}


export type ForeignKeyReferenceDialogProps = {
  tableMetadata: DataModelMetadata.Aggregate
  onSelect: (record: EditableDbRecord) => void
  onCancel: () => void
}


/**
 * 外部参照テーブルのレコード選択ダイアログ
 */
export const ForeignKeyReferenceDialog = ({
  tableMetadata,
  onSelect,
  onCancel,
}: ForeignKeyReferenceDialogProps) => {
  const { getDbRecords } = useQueryEditorServerApi()
  const [records, setRecords] = React.useState<EditableDbRecord[]>()
  const [error, setError] = React.useState<string | null>(null)

  React.useEffect(() => {
    (async () => {
      const res = await getDbRecords({
        tableName: tableMetadata.tableName,
        whereClause: "",
      })
      if (res.ok) {
        setRecords(res.data.records)
      } else {
        setError(res.error)
      }
    })()
  }, [])

  const columnDefs: Layout.GetColumnDefsFunction<EditableDbRecord> = React.useCallback(cellType => {
    // 選択
    const selectColumn = cellType.other('', {
      defaultWidth: 60,
      isFixed: true,
      renderCell: cell => (
        <Input.IconButton underline mini onClick={() => {
          onSelect(cell.row.original)
        }}>
          選択
        </Input.IconButton>
      ),
    })

    const valueColumns: Layout.EditableGridColumnDef<EditableDbRecord>[] = []

    for (const column of tableMetadata.members) {
      if (column.type === "root" || column.type === "child" || column.type === "children") {
        // 子テーブルは別のウィンドウ
        continue
      } else if (column.type === "own-column" || column.type === "parent-key" || column.type === "ref-key") {
        valueColumns.push(cellType.text(
          `values.${column.columnName}` as ReactHookForm.FieldPathByValue<EditableDbRecord, string | undefined>,
          column.columnName ?? '',
          {}))
      } else {
        throw new Error(`不明な列の種類: ${column.type}`)
      }
    }

    return [
      selectColumn,
      ...valueColumns,
    ]
  }, [tableMetadata])

  return (
    <Layout.ModalDialog
      open
      className="relative w-[80vw] h-[80vh] bg-white flex flex-col gap-1 relative border border-gray-400"
    >
      <div className="h-full w-full flex flex-col p-1 gap-1">

        <div className="flex gap-1 p-1">
          <span className="font-bold">
            {tableMetadata.tableName}
          </span>
          <div className="flex-1"></div>
          <Input.IconButton outline mini onClick={onCancel}>
            キャンセル
          </Input.IconButton>
        </div>

        {error && (
          <div className="text-red-500 flex-1">
            {error}
          </div>
        )}
        {records && (
          <Layout.EditableGrid
            rows={records}
            getColumnDefs={columnDefs}
            className="flex-1"
          />
        )}
      </div>

      {!error && !records && (
        <Layout.NowLoading />
      )}
    </Layout.ModalDialog>
  )
}
