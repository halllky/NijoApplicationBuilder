using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using NLog;
using NLog.Config;
using NLog.Targets;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace MyApp.Core;

public class OverridedApplicationConfigure : DefaultConfiguration {

    public override void ConfigureServices(IServiceCollection services) {
        // 自動生成される設定処理はすべて行なう
        base.ConfigureServices(services);

        // このクラスの解決
        services.AddTransient<DefaultConfiguration, OverridedApplicationConfigure>();

        // アプリケーションサービス（具象クラス）
        services.AddScoped(provider => {
            return new OverridedApplicationService(provider);
        });

        // 実行時設定（appsettings.json）
        services.AddTransient(provider => {
            var settings = new RuntimeSetting();
            new ConfigurationBuilder()
                .AddJsonFile("appsettings.json", false)
                .AddJsonFile("appsettings.Development.json", true)
                .Build()
                .GetSection("Nijo")
                .Bind(settings);
            return settings;
        });
    }


    protected override AutoGeneratedApplicationService ConfigureApplicationService(IServiceProvider services) {
        return new OverridedApplicationService(services);
    }

    #region DB
    /// <summary>
    /// DBコンテキスト接続設定
    /// </summary>
    protected override void ConfigureDbContext(IServiceProvider services, DbContextOptionsBuilder options) {
        // SQLiteを使用する
        var settings = services.GetRequiredService<RuntimeSetting>();
        var connStr = settings.GetCurrentProfile().ConnStr;
        options.UseSqlite(connStr);

        // 自動生成される登録更新処理は変更追跡オフが前提
        options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
    }

    /// <summary>
    /// <see cref="DbContext.OnConfiguring(DbContextOptionsBuilder)"/>
    /// </summary>
    public override void OnConfiguringDbContext(DbContextOptionsBuilder optionsBuilder, Logger logger) {
        // SQL発行時にログ出力するようにする
        optionsBuilder.LogTo(
            sql => logger.Debug(sql),
            Microsoft.Extensions.Logging.LogLevel.Information,
            Microsoft.EntityFrameworkCore.Diagnostics.DbContextLoggerOptions.SingleLine);
    }

    /// <summary>
    /// モデルのカスタマイズ
    /// </summary>
    public override void OnModelCreating(ModelBuilder modelBuilder) {
        // 診療収益分析SearchResult
        var 診療収益分析Entity = modelBuilder.Entity<診療収益分析SearchResult>();
        診療収益分析Entity.ToView("V_診療収益分析");
        診療収益分析Entity.HasKey(e => new { e.年月, e.診療科_診療科ID });

        // 機器分類別収益SearchResult
        var 機器分類別収益Entity = modelBuilder.Entity<機器分類別収益SearchResult>();
        機器分類別収益Entity.ToView("V_機器分類別収益");
        機器分類別収益Entity.HasKey(e => new { e.診療収益分析_年月, e.診療収益分析_診療科_診療科ID, e.機器分類_機器分類ID });

        // 機器別収益SearchResult
        var 機器別収益Entity = modelBuilder.Entity<機器別収益SearchResult>();
        機器別収益Entity.ToView("V_機器別収益");
        機器別収益Entity.HasKey(e => new { e.機器分類別収益_診療収益分析_年月, e.機器分類別収益_診療収益分析_診療科_診療科ID, e.機器分類別収益_機器分類_機器分類ID, e.医療機器_機器ID });

        // 時間帯別収益SearchResult
        var 時間帯別収益Entity = modelBuilder.Entity<時間帯別収益SearchResult>();
        時間帯別収益Entity.ToView("V_時間帯別収益");
        時間帯別収益Entity.HasKey(e => new { e.診療収益分析_年月, e.診療収益分析_診療科_診療科ID, e.時間帯 });

        // リレーションシップの設定
        診療収益分析Entity.HasMany(e => e.機器分類別収益)
            .WithOne(e => e.診療収益分析)
            .HasForeignKey(e => new {
                e.診療収益分析_年月,
                e.診療収益分析_診療科_診療科ID,
            });

        機器分類別収益Entity.HasMany(e => e.機器別収益)
            .WithOne(e => e.機器分類別収益)
            .HasForeignKey(e => new {
                e.機器分類別収益_診療収益分析_年月,
                e.機器分類別収益_診療収益分析_診療科_診療科ID,
                e.機器分類別収益_機器分類_機器分類ID,
            });

        診療収益分析Entity.HasMany(e => e.時間帯別収益)
            .WithOne(e => e.診療収益分析)
            .HasForeignKey(e => new {
                e.診療収益分析_年月,
                e.診療収益分析_診療科_診療科ID,
            });
    }
    #endregion DB

    #region ログ
    /// <summary>
    /// ログファイル名規則。表記はNLogのルールに従う。
    /// </summary>
    protected virtual string LogFileNameRule => "${date:format=yyyy-MM-dd}.log";
    /// <summary>
    /// ログ出力設定
    /// </summary>
    protected override Logger ConfigureLogger(IServiceProvider services) {
        var settings = services.GetRequiredService<RuntimeSetting>();
        var config = new LoggingConfiguration();

        // ファイル出力
        var fileTarget = new FileTarget("logfile") {
            FileName = Path.Combine(Directory.GetCurrentDirectory(), settings.LogDirectory, LogFileNameRule),
            Layout = "${longdate}\t${level:uppercase=true}\t${logger}\t${message}${onexception:inner=${newline}${exception:format=tostring}}",
            ArchiveFileName = Path.Combine(settings.LogDirectory, "archive", "${date:format=yyyy-MM-dd}.{#}.log"),
            ArchiveNumbering = ArchiveNumberingMode.Sequence,
            ArchiveAboveSize = 5 * 1024 * 1024, // 5MBを越えたらアーカイブ
            MaxArchiveFiles = 100
        };
        config.AddTarget(fileTarget);
        config.AddRuleForAllLevels(fileTarget);

        // 設定を適用して新しいロガーを作成
        LogManager.Configuration = config;
        return LogManager.GetCurrentClassLogger();
    }
    #endregion ログ


    #region JSONシリアライズ設定
    public override JsonSerializerOptions EditDefaultJsonSerializerOptions(JsonSerializerOptions option) {
        base.EditDefaultJsonSerializerOptions(option);

        // 型ごとのシリアライズ設定
        option.Converters.Add(new DateTimeConverter());
        option.Converters.Add(new DateOnlyConverter());
        option.Converters.Add(new YearMonthJsonConverter());
        option.Converters.Add(new EnumDisplayNameConverterFactory());

        // 日本語などがUnicodeエスケープされるのを防ぐ
        option.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;

        // nullはJSONに含めない
        option.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;

        return option;
    }
    /// <summary>
    /// 日付時刻。ISO8601形式でシリアライズする。空文字はnullとみなす
    /// </summary>
    private class DateTimeConverter : JsonConverter<DateTime?> {
        public override DateTime? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            var strValue = reader.GetString();
            if (string.IsNullOrWhiteSpace(strValue)) {
                return null;
            }
            return DateTime.Parse(strValue);
        }
        public override void Write(Utf8JsonWriter writer, DateTime? value, JsonSerializerOptions options) {
            if (value == null) {
                writer.WriteNullValue();
            } else {
                writer.WriteStringValue(value.Value.ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ"));
            }
        }
    }
    /// <summary>
    /// 日付。yyyy-MM-dd形式でシリアライズする。空文字はnullとみなす
    /// </summary>
    private class DateOnlyConverter : JsonConverter<DateOnly?> {
        public override DateOnly? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            var strValue = reader.GetString();
            if (string.IsNullOrWhiteSpace(strValue)) {
                return null;
            }
            return DateOnly.Parse(strValue);
        }
        public override void Write(Utf8JsonWriter writer, DateOnly? value, JsonSerializerOptions options) {
            if (value == null) {
                writer.WriteNullValue();
            } else {
                writer.WriteStringValue(value.ToString());
            }
        }
    }
    /// <summary>
    /// 年月。yyyy/MM形式でシリアライズする。空文字はnullとみなす
    /// </summary>
    public class YearMonthJsonConverter : JsonConverter<YearMonth?> {
        public override YearMonth? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            if (reader.TokenType == JsonTokenType.Number) {
                return new YearMonth(reader.GetInt32());

            } else if (reader.TokenType == JsonTokenType.String) {
                string value = reader.GetString() ?? throw new JsonException();

                if (string.IsNullOrWhiteSpace(value)) {
                    return null;
                }

                if (int.TryParse(value, out int result)) {
                    return new YearMonth(result);
                }

                // YYYY/MM形式の場合
                if (value.Length == 7 && value[4] == '/') {
                    int year = int.Parse(value.Substring(0, 4));
                    int month = int.Parse(value.Substring(5, 2));
                    return new YearMonth(year, month);
                }

                throw new JsonException($"不正な年月形式です: {value}");
            }

            throw new JsonException();
        }

        public override void Write(Utf8JsonWriter writer, YearMonth? value, JsonSerializerOptions options) {
            if (value == null) {
                writer.WriteNullValue();
            } else {
                writer.WriteStringValue($"{value.Value.Year:0000}/{value.Value.Month:00}");
            }
        }
    }
    /// <summary>
    /// enumのJSONシリアライズ設定。Display属性が指定されている場合はそれが優先。指定なしの場合は物理名でシリアライズ
    /// </summary>
    private class EnumDisplayNameConverterFactory : JsonConverterFactory {
        public override bool CanConvert(Type typeToConvert) {
            // 通常のenum型、またはNullable<enum>型をサポート
            return typeToConvert.IsEnum || (Nullable.GetUnderlyingType(typeToConvert)?.IsEnum ?? false);
        }

        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options) {
            // typeToConvert が Nullable<TEnum> の場合は TEnum を、
            // そうでなければそのままの型 (TEnum) を取得する。
            var underlyingType = Nullable.GetUnderlyingType(typeToConvert);
            var enumTypeToConvert = underlyingType ?? typeToConvert;

            // EnumDisplayNameConverter<TEnum> を作成 (TEnum は非nullableなenum型)
            var converterType = typeof(EnumDisplayNameConverter<>).MakeGenericType(enumTypeToConvert);

            // EnumDisplayNameConverter のコンストラクタに引数がないことをユーザーが修正済みのため、引数なしでインスタンス化
            return (JsonConverter)Activator.CreateInstance(converterType)!;
        }
    }
    /// <summary>
    /// enumのJSONシリアライズ設定。[Display(Name = "...")]属性が指定されている場合はNameの値でシリアライズされる。指定なしの場合は物理名でシリアライズ
    /// </summary>
    private class EnumDisplayNameConverter<T> : JsonConverter<T?> where T : struct, Enum {

        // Display属性の値とenumの値のマッピングのキャッシュ
        private Dictionary<string, T>? _enumDisplayNameMap;
        private Dictionary<string, T> GetEnumDisplayNameMap() {
            _enumDisplayNameMap ??= Enum
                .GetValues<T>()
                .ToDictionary(e => e.GetType().GetField(e.ToString())?.GetCustomAttribute<DisplayAttribute>()?.Name ?? e.ToString(), e => e);
            return _enumDisplayNameMap;
        }

        public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {
            // [Display(Name = "...")]属性が指定されている場合はNameの値でシリアライズされるため strValueは Name の値。
            // GetCustomAttribute で取得した Name 属性の値と突き合わせ、一致するものを探す。
            var strValue = reader.GetString();

            // 空文字はnull
            if (string.IsNullOrWhiteSpace(strValue)) {
                return default;
            }

            // GetCustomAttribute で取得した Name 属性の値と突き合わせ、一致するものを探す。
            var dict = GetEnumDisplayNameMap();
            if (dict.TryGetValue(strValue, out var enumValue)) {
                return enumValue;
            }

            // 一致するものがない場合は例外
            throw new JsonException($"不正なenum値です: {strValue}");
        }

        public override void Write(Utf8JsonWriter writer, T? value, JsonSerializerOptions options) {
            if (value == null) {
                writer.WriteNullValue();
            } else {
                // [Display(Name = "...")]属性が指定されている場合はNameの値でシリアライズ
                var displayName = GetEnumDisplayNameMap().Single(e => e.Value.Equals(value.Value)).Key;
                writer.WriteStringValue(displayName);
            }
        }
    }
    #endregion JSONシリアライズ設定
}
