using Microsoft.EntityFrameworkCore;
using MyApp.Core;
using MyApp.Core.Debugging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyApp.Core;

partial class DB接続あり_更新なし {

    /// <summary>
    /// LINQ式をSQLに変換できないときはこの例外メッセージになる
    /// </summary>
    private const string CANNOT_TRANSRATE_TO_SQL = @"could not be translated. Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable', 'AsAsyncEnumerable', 'ToList', or 'ToListAsync'. See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.";

    [Category("無条件検索でエラーが発生しないか（一覧検索）")]
    [TestCaseSource(typeof(QueryModelTestCases), nameof(QueryModelTestCases.無条件検索テストケース))]
    public async Task 無条件検索でエラーが発生しないか(
        string testCasePhysicalName,
        Type messageContainerType,
        Func<AutoGeneratedApplicationService, IPresentationContext, Task<IEnumerable<object>>> test) {

        // ダミーデータ投入
        var scope = TestUtilImpl.Instance.CreateScope($"{nameof(無条件検索でエラーが発生しないか)}_{testCasePhysicalName}", messageContainerType);

        var generator = new OverridedDummyDataGenerator();
        var dbDescriptor = new DummyDataDbOutput(scope.App.DbContext);
        await generator.GenerateAsync(dbDescriptor);

        // 無条件検索を実行
        try {
            var result = await test(scope.App, scope.PresentationContext);
            scope.App.Log.Debug("取得したデータ: {0}", scope.App.Configuration.ToJson(result));
            Assert.Pass("例外発生せず");

        } catch (InvalidOperationException ex) when (ex.Message.Contains(CANNOT_TRANSRATE_TO_SQL)) {
            if (testCasePhysicalName == "アクション結果"
             || testCasePhysicalName == "在庫調査報告") {
                Assert.Inconclusive(
                    "この集約は式が複雑すぎてSQLに変換できないが（EFCoreの制約）、" +
                    "自動生成されたコードでコンパイルエラーが出ないことを確認したいので、あえて残している。" +
                    "通常の運用では、参照経路が深くなりすぎないよう、RefTo用のQueryModelを別途定義し、それを参照させることで回避する。");
            } else {
                throw;
            }
        }
    }

    [Category("無条件検索でエラーが発生しないか（外部参照検索）")]
    [TestCaseSource(typeof(QueryModelTestCases), nameof(QueryModelTestCases.無条件外部参照検索テストケース))]
    public async Task 無条件外部参照検索でエラーが発生しないか(
        string testCasePhysicalName,
        Type messageContainerType,
        Func<AutoGeneratedApplicationService, IPresentationContext, Task<IEnumerable<object>>> test) {

        // ダミーデータ投入
        var scope = TestUtilImpl.Instance.CreateScope($"{nameof(無条件外部参照検索でエラーが発生しないか)}_{testCasePhysicalName}", messageContainerType);

        var generator = new OverridedDummyDataGenerator();
        var dbDescriptor = new DummyDataDbOutput(scope.App.DbContext);
        await generator.GenerateAsync(dbDescriptor);

        // 無条件外部参照検索を実行
        try {
            var result = await test(scope.App, scope.PresentationContext);
            scope.App.Log.Debug("取得したデータ: {0}", scope.App.Configuration.ToJson(result));
            Assert.Pass("例外発生せず");

        } catch (InvalidOperationException ex) when (ex.Message.Contains(CANNOT_TRANSRATE_TO_SQL)) {
            if (testCasePhysicalName == "アクション") {
                Assert.Inconclusive(
                    "この集約は式が複雑すぎてSQLに変換できないが（EFCoreの制約）、" +
                    "自動生成されたコードでコンパイルエラーが出ないことを確認したいので、あえて残している。" +
                    "通常の運用では、参照経路が深くなりすぎないよう、RefTo用のQueryModelを別途定義し、それを参照させることで回避する。");
            } else {
                throw;
            }
        }
    }

    [Test]
    [Category("無条件検索でエラーが発生しないか（生SQLにマップされるQueryModelのテスト）")]
    public void 生SQLにマップされるQueryModelのテスト() {
        var scope = TestUtilImpl.Instance.CreateScope(nameof(生SQLにマップされるQueryModelのテスト));

        //var result = scope.App.DbContext
        //    .Set<売上分析SearchResult>()
        //    .Include(e => e.カテゴリ別売上)
        //    .ThenInclude(e => e.商品別売上)
        //    .Include(e => e.時間帯別売上)
        //    .ToArray();

        var result = scope.App.DbContext
            .Set<売上分析SearchResult>()
            .Where(e => e.売上合計 >= 12345.1m)
            .Select(e => new {
                e.年月,
            })
            .ToArray();

        scope.App.Log.Debug("取得したデータ: {0}", scope.App.Configuration.ToJson(result));
    }
}
