using Nijo.Util.DotnetEx;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Nijo.Parts {
    /// <summary>
    /// アプリケーションテンプレート（このプロジェクトの隣にあるプロジェクト）の埋め込みリソース
    /// </summary>
    internal class EmbeddedResource {

        private static string ToResourceName(IEnumerable<string> relativePath) {
            // EmbeddedResourceのマニフェスト名ではフォルダ階層のセパレータがピリオドになる
            return $"{LINKBASE}.{relativePath.Join(".")}";
        }

        /// <summary>csproj内で指定しているLinkBaseと合わせる</summary>
        private const string LINKBASE = "Nijo.テンプレ";

        /// <summary>
        /// テンプレートプロジェクトは埋め込みリソースとしてビルドに含まれるが、
        /// サブディレクトリは"/"でなく"."で区切られた名前で登録される。
        /// これによってリソース名のうちどこまでがフォルダなのかが判別できなくなってしまうので、
        /// ここで登録された名前か否かでフォルダかファイルかを区別している。
        /// </summary>
        private static IEnumerable<string> GetEmbeddedResourceDirNames() {
            yield return LINKBASE + ".react";
            yield return LINKBASE + ".react.public";
            yield return LINKBASE + ".react.src";
            yield return LINKBASE + ".react.src.debug-room";
            yield return LINKBASE + ".react.src.util2";
            yield return LINKBASE + ".react.src.__autoGenerated";
            yield return LINKBASE + ".react.src.__autoGenerated.collection";
            yield return LINKBASE + ".react.src.__autoGenerated.input";
            yield return LINKBASE + ".react.src.__autoGenerated.ref_to";
            yield return LINKBASE + ".react.src.__autoGenerated.util";
            yield return LINKBASE + ".react.src.__autoGenerated.pages";
            yield return LINKBASE + ".core";
            yield return LINKBASE + ".cli";
            yield return LINKBASE + ".cli.__AutoGenerated";
            yield return LINKBASE + ".webapi";
            yield return LINKBASE + ".webapi.Properties";
            yield return LINKBASE + ".webapi.__AutoGenerated";
            yield return LINKBASE + ".webapi.__AutoGenerated.Util";
        }


        private EmbeddedResource(IEnumerable<string> relativePath, Assembly assembly) {
            _resourceName = ToResourceName(relativePath);
            _assembly = assembly;
        }
        private EmbeddedResource(string value, Assembly assembly) {
            _resourceName = value;
            _assembly = assembly;
        }
        private readonly string _resourceName;
        private readonly Assembly _assembly;

        internal StreamReader GetStreamReader() {
            var stream = _assembly.GetManifestResourceStream(_resourceName)
                ?? throw new InvalidOperationException($"埋め込みリソースが見つかりません: {_resourceName}");
            return new StreamReader(stream);
        }

        internal string RelativePath
            => Path.Combine(DirName, FileName);

        internal string FileName
            => _resourceName.Substring(LINKBASE.Length + 1 + DirName.Length + 1);

        internal string DirName {
            get {
                var dirname = GetEmbeddedResourceDirNames()
                    .Where(dirname => _resourceName.StartsWith(dirname))
                    .OrderByDescending(dirname => dirname.Length)
                    .First();
                dirname = dirname.Substring(LINKBASE.Length + 1);
                dirname = dirname.Replace('.', Path.DirectorySeparatorChar);
                return dirname;
            }
        }


        internal class Collection {
            internal Collection(Assembly assembly) {
                _assembly = assembly;
            }
            private readonly Assembly _assembly;

            internal EmbeddedResource Get(params string[] fileRelativePath) {
                return new EmbeddedResource(fileRelativePath, _assembly);
            }

            /// <summary>
            /// ルート直下にあるファイルはディレクトリ名とファイル名を区別しづらいので直指定せざるを得ない
            /// </summary>
            internal EmbeddedResource FromResourceName(string resourceName) {
                return new EmbeddedResource($"{LINKBASE}.{resourceName}", _assembly);
            }

            internal IEnumerable<EmbeddedResource> Enumerate(params string[] directoryRelativePath) {
                var name = ToResourceName(directoryRelativePath);
                foreach (var resourceName in _assembly.GetManifestResourceNames()) {
                    if (resourceName.StartsWith(name))
                        yield return new EmbeddedResource(resourceName, _assembly);
                }
            }
        }
    }
}
