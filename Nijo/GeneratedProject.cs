using Microsoft.Extensions.Logging;
using Nijo.CodeGenerating;
using Nijo.Parts.CSharp;
using Nijo.Parts.JavaScript;
using Nijo.SchemaParsing;
using Nijo.ImmutableSchema;
using Nijo.Parts.Common;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using Nijo.Util.DotnetEx;
using Nijo.Parts.Document;
using System.Diagnostics.CodeAnalysis;

namespace Nijo {
    /// <summary>
    /// 自動生成されるプロジェクトに対する操作を提供します。
    /// </summary>
    public class GeneratedProject {

        private const string NIJO_XML = "nijo.xml";

        public static bool TryOpen(string projectRoot, [NotNullWhen(true)] out GeneratedProject? project, [NotNullWhen(false)] out string? error) {
            if (!Directory.Exists(projectRoot)) {
                project = null;
                error = "フォルダが存在しません。";
                return false;
            }

            var nijoXmlPath = Path.Combine(projectRoot, NIJO_XML);
            if (!File.Exists(nijoXmlPath)) {
                project = null;
                error = $"スキーマ定義ファイルが存在しません。右記パスにスキーマ定義パスを配置してください: {nijoXmlPath}";
                return false;
            }

            project = new GeneratedProject(Path.GetFullPath(projectRoot));
            error = null;
            return true;
        }

        private GeneratedProject(string projectRoot) {
            ProjectRoot = projectRoot;
        }

        /// <summary>プロジェクトのルートディレクトリの絶対パス</summary>
        public string ProjectRoot { get; }
        /// <summary>プロジェクトのスキーマ定義XMLの絶対パス</summary>
        public string SchemaXmlPath => Path.Combine(ProjectRoot, NIJO_XML);

        public string CoreLibraryRoot => Path.Combine(ProjectRoot, "core.AutoGenerated");
        public string CoreLibraryOverrideRoot => Path.Combine(ProjectRoot, "core");
        public string WebapiProjectRoot => Path.Combine(ProjectRoot, "webapi");
        public string ReactProjectRoot => Path.Combine(ProjectRoot, "react");
        public string UnitTestProjectRoot => Path.Combine(ProjectRoot, "Test");
        public string DocumentRoot => Path.Combine(ProjectRoot, "Document");

        /// <summary>
        /// このプロジェクトのソースコード自動生成設定を返します。
        /// </summary>
        public CodeRenderingConfig GetConfig() {
            var xDocument = XDocument.Load(SchemaXmlPath);
            return new CodeRenderingConfig(xDocument);
        }

        /// <summary>
        /// スキーマ定義の検証を行ないます。
        /// </summary>
        public bool ValidateSchema(SchemaParseContext parseContext, ILogger logger) {
            return parseContext.TryBuildSchema(parseContext.Document, out var _, logger);
        }

        /// <summary>
        /// コード自動生成を実行します。
        /// </summary>
        internal void GenerateCode(SchemaParseContext parseContext, ILogger logger) {
            // スキーマ定義のコレクションを作成
            if (!parseContext.TryBuildSchema(parseContext.Document, out var immutableSchema, logger)) {
                logger.LogError("エラーがある状態でソースコードの自動生成を行なうことはできません。");
                return;
            }

            var ctx = new CodeRenderingContext(this, GetConfig(), parseContext, immutableSchema);

            logger.LogInformation("ソース自動生成開始");

            // ルート集約毎のコードを生成
            foreach (var rootAggregate in immutableSchema.GetRootAggregates()) {
                logger.LogInformation("レンダリング開始: {name}", rootAggregate.DisplayName);
                try {
                    rootAggregate.Model.GenerateCode(ctx, rootAggregate);
                } catch (Exception ex) {
                    throw new InvalidOperationException($"{rootAggregate}のレンダリングで例外が発生", ex);
                }

                // 自動生成ドキュメント
                ctx.Use<MarkdownDocument>().AddToIndexReadme(rootAggregate);
            }

            // ルート集約と対応しないコードを生成
            foreach (var model in parseContext.Models.Values) {
                logger.LogInformation("レンダリング開始: {name}", model.GetType().Name);
                try {
                    model.GenerateCode(ctx);
                } catch (Exception ex) {
                    throw new InvalidOperationException($"{model.GetType().Name}のレンダリングで例外が発生", ex);
                }
            }

            // IMultiAggregateSourceFile が別の IMultiAggregateSourceFile に依存することがあるので、
            // すべて漏らさず確実に依存関係を登録させる。
            // ソース自動生成中で一度でも登場した IMultiAggregateSourceFile それぞれ必ず1回ずつ依存関係登録メソッドを呼ぶ
            var handled = new HashSet<IMultiAggregateSourceFile>();
            while (true) {
                var appeared = ctx.GetMultiAggregateSourceFiles();
                var unhandled = appeared.Where(src => !handled.Contains(src)).ToArray();

                if (unhandled.Length == 0) {
                    break; // 全ての IMultiAggregateSourceFile の依存関係登録メソッドが呼ばれたら終了
                }
                foreach (var src in unhandled) {
                    src.RegisterDependencies(ctx);
                    handled.Add(src);
                }
            }

            // スキーマ定義にかかわらず必ず生成されるモジュールの登録
            ctx.Use<ApplicationService>();
            ctx.Use<JsonUtil>();
            AspNetController.RegisterWebapiConfiguration(ctx);

            // 以降は IMultiAggregateSourceFile の新規登録不可
            ctx.StopUseMultiAggregateSourceFiles();

            // IMultiAggregateSourceFile のレンダリング実行
            foreach (var src in ctx.GetMultiAggregateSourceFiles()) {
                logger.LogInformation("レンダリング開始: {name}", src.GetType().Name);
                try {
                    src.Render(ctx);
                } catch (Exception ex) {
                    throw new InvalidOperationException($"{src.GetType().Name}のレンダリングで例外が発生", ex);
                }
            }

            // スキーマ定義にかかわらず必ず生成されるモジュールを生成する
            foreach (var vmType in parseContext.GetValueMemberTypes()) {
                logger.LogInformation("レンダリング開始: {name}", vmType.GetType().Name);
                vmType.RenderStaticSources(ctx);
            }
            ctx.CoreLibrary(autoGenerated => {
                autoGenerated.Directory("Util", dir => {
                    dir.Generate(PresentationContext.RenderStaticCore(ctx));
                    dir.Generate(CharacterType.Render(ctx));
                    dir.Generate(FromTo.Render(ctx));
                });
            });
            ctx.WebapiProject(autoGenerated => {
                autoGenerated.Directory("Util", dir => {
                    dir.Generate(AspNetController.RenderAutoGeneratedEndpointAttribute(ctx));
                    dir.Generate(E_AutoGeneratedActionType.RenderDeclaring(ctx));
                });
            });
            ctx.UnitTestProject(autoGenerated => {
                autoGenerated.Generate(Parts.UnitTest.AutoGeneratedTest.Render(ctx));
                autoGenerated.Directory("Util", dir => {
                    dir.Generate(Parts.UnitTest.TestUtil.Render(ctx));
                });
            });
            ctx.ReactProject(autoGenerated => {
                autoGenerated.Directory("util", dir => {
                    dir.Generate(Models.QueryModelModules.UiConstraint.RenderCommonConstraint(ctx));
                });
            });

            // index.tsの生成
            ctx.ReactProject(autoGenerated => {
                autoGenerated.Directory("util", dir => {
                    IndexTs.Render(dir, ctx);
                });
            });

            // 生成されていないファイルやディレクトリを削除
            ctx.CleanUnhandledFilesAndDirectories();

            logger.LogInformation("ソース自動生成終了");
        }
    }
}
