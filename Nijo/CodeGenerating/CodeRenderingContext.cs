using Nijo.ImmutableSchema;
using Nijo.SchemaParsing;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace Nijo.CodeGenerating {
    /// <summary>
    /// ソースコード自動生成のコンテキスト情報
    /// </summary>
    public sealed class CodeRenderingContext : IMultiAggregateSourceFileManager {
        internal CodeRenderingContext(GeneratedProject project, GeneratedProjectOptions options, SchemaParseContext xmlParseContext, ApplicationSchema immutableSchema) {
            Project = project;
            Config = options;
            SchemaParser = xmlParseContext;
            _immutableSchema = immutableSchema;
        }

        public GeneratedProject Project { get; }
        public GeneratedProjectOptions Config { get; }

        private readonly ApplicationSchema _immutableSchema;

        private const string AUTOGENERATED_CORE = "__AutoGenerated";
        private const string AUTOGENERATED_WEBAPI = "__AutoGenerated";
        private const string AUTOGENERATED_UNIT_TEST = "__AutoGenerated";
        private const string AUTOGENERATED_REACT = "__autoGenerated";
        private const string AUTOGENERATED_DOCUMENT = "__AutoGenerated";

        /// <summary>
        /// C#のクラスライブラリのソースコード自動生成フォルダのルート。
        /// コードが自動生成される主たるプロジェクト。
        /// </summary>
        public void CoreLibrary(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.CoreLibraryRoot, dir => {
                dir.Directory(AUTOGENERATED_CORE, setup);
            });
        }
        /// <summary>
        /// ASP.NET Core プロジェクトのソースコード自動生成フォルダのルート。
        /// </summary>
        public void WebapiProject(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.WebapiProjectRoot, dir => {
                dir.Directory(AUTOGENERATED_WEBAPI, setup);
            });
        }
        /// <summary>
        /// React.js プロジェクトのソースコード自動生成フォルダのルート。
        /// </summary>
        public void ReactProject(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.ReactProjectRoot, dir => {
                dir.Directory("src", srcDir => {
                    srcDir.Directory(AUTOGENERATED_REACT, setup);
                });
            });
        }
        /// <summary>
        /// ユニットテストのソースコード自動生成フォルダのルート。
        /// </summary>
        public void UnitTestProject(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.UnitTestProjectRoot, dir => {
                dir.Directory(AUTOGENERATED_UNIT_TEST, setup);
            });
        }
        /// <summary>
        /// ドキュメントが自動生成されるフォルダのルート。
        /// </summary>
        public void DocumentDirectory(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.DocumentRoot, dir => {
                dir.Directory(AUTOGENERATED_DOCUMENT, setup);
            });
        }


        #region 集約定義の解釈ルール
        /// <inheritdoc cref="SchemaParseContext"/>
        internal SchemaParseContext SchemaParser { get; }
        #endregion 集約定義の解釈ルール


        #region 複数の集約からレンダリングされるソースファイルの管理
        /// <inheritdoc cref="IMultiAggregateSourceFileManager.Use{T}"/>
        public T Use<T>() where T : IMultiAggregateSourceFile, new() {
            if (_stopUseMultiAggregateSourceFiles) {
                throw new InvalidOperationException($"{nameof(IMultiAggregateSourceFile)} のレンダリング中に {nameof(Use)} が呼ばれた可能性があります。");
            }

            var instance = _multiAggregateSources.OfType<T>().SingleOrDefault();
            if (instance == null) {
                instance = new T();
                _multiAggregateSources.Add(instance);
            }

            return instance;
        }
        /// <summary>
        /// 複数の集約から1つのファイルが生成される類のファイルを返します。
        /// </summary>
        internal IEnumerable<IMultiAggregateSourceFile> GetMultiAggregateSourceFiles() {
            return _multiAggregateSources;
        }
        /// <summary>
        /// <see cref="IMultiAggregateSourceFile"/> のレンダリング開始後に
        /// <see cref="Use{T}"/> が呼ばれてしまうとレンダリングが実行されない可能性があるため
        /// このメソッドが呼ばれた後は <see cref="Use{T}"/> 使用不可
        /// </summary>
        internal void StopUseMultiAggregateSourceFiles() {
            _stopUseMultiAggregateSourceFiles = true;
        }

        private readonly HashSet<IMultiAggregateSourceFile> _multiAggregateSources = [];
        private bool _stopUseMultiAggregateSourceFiles = false;
        #endregion 複数の集約からレンダリングされるソースファイルの管理


        #region ソースコード自動生成で登場しなかった既存ファイルの削除
        private readonly HashSet<string> _handled = new();
        internal void Handle(string fullpath) => _handled.Add(Path.GetFullPath(fullpath));
        internal bool IsHandled(string fullpath) => _handled.Contains(Path.GetFullPath(fullpath));
        /// <summary>
        /// このコンテキストで生成されていないファイルやディレクトリを削除します。
        /// </summary>
        internal void CleanUnhandledFilesAndDirectories() {
            var allFiles = new List<string>();
            var core = Path.Combine(Project.CoreLibraryRoot, AUTOGENERATED_CORE);
            var webapi = Path.Combine(Project.WebapiProjectRoot, AUTOGENERATED_WEBAPI);
            var react = Path.Combine(Project.ReactProjectRoot, "src", AUTOGENERATED_REACT);
            var test = Path.Combine(Project.UnitTestProjectRoot, AUTOGENERATED_UNIT_TEST);
            var document = Path.Combine(Project.DocumentRoot, AUTOGENERATED_DOCUMENT);
            if (Directory.Exists(core)) allFiles.AddRange(Directory.GetFiles(core, "*", SearchOption.AllDirectories));
            if (Directory.Exists(webapi)) allFiles.AddRange(Directory.GetFiles(webapi, "*", SearchOption.AllDirectories));
            if (Directory.Exists(react)) allFiles.AddRange(Directory.GetFiles(react, "*", SearchOption.AllDirectories));
            if (Directory.Exists(test)) allFiles.AddRange(Directory.GetFiles(test, "*", SearchOption.AllDirectories));
            if (Directory.Exists(document)) allFiles.AddRange(Directory.GetFiles(document, "*", SearchOption.AllDirectories));

            foreach (var file in allFiles) {
                if (_handled.Contains(Path.GetFullPath(file))) continue;
                if (!File.Exists(file)) continue;
                File.Delete(file);
            }

            var allDirectories = new List<string>();
            if (Directory.Exists(core)) allDirectories.AddRange(Directory.GetDirectories(core, "*", SearchOption.AllDirectories));
            if (Directory.Exists(webapi)) allDirectories.AddRange(Directory.GetDirectories(webapi, "*", SearchOption.AllDirectories));
            if (Directory.Exists(react)) allDirectories.AddRange(Directory.GetDirectories(react, "*", SearchOption.AllDirectories));
            if (Directory.Exists(test)) allDirectories.AddRange(Directory.GetDirectories(test, "*", SearchOption.AllDirectories));
            if (Directory.Exists(document)) allDirectories.AddRange(Directory.GetDirectories(document, "*", SearchOption.AllDirectories));

            foreach (var dir in allDirectories) {
                if (_handled.Contains(Path.GetFullPath(dir))) continue;
                if (!Directory.Exists(dir)) continue;
                Directory.Delete(dir, true);
            }
        }
        /// <summary>
        /// 現時点で特定のディレクトリ内に生成されたファイルの一覧を返します。
        /// </summary>
        public IEnumerable<string> GetGeneratedFileNames(DirectorySetupper dir) {
            return _handled.Where(path => dir.Path == Path.GetDirectoryName(path));
        }
        #endregion ソースコード自動生成で登場しなかった既存ファイルの削除


        #region ToOrderedByDataFlow
        /// <summary>
        /// ルート集約を、ref-toによる外部参照の関係性に従い、
        /// 参照される方を先、参照する方を後、とする順番に並び替えた新しいインスタンスを返します。
        /// </summary>
        public IEnumerable<RootAggregate> ToOrderedByDataFlow(IEnumerable<RootAggregate> rootAggregates) {
            if (_rootAggregateOrderCache == null) {
                _rootAggregateOrderCache = new();

                // 列挙するたびにこのリストから集約をクリアしていき、
                // このリストから全ての集約が無くなったら列挙完了
                var rest = rootAggregates.Select(root => new {
                    root,
                    refTargets = root
                        .EnumerateThisAndDescendants()
                        .SelectMany(agg => agg.GetMembers())
                        .OfType<RefToMember>()
                        .Select(refTo => refTo.RefTo.GetRoot())
                        .ToHashSet(),
                }).ToList();

                var index = 0;
                while (true) {
                    if (rest.Count == 0) break;

                    var next = rest[index];

                    // 参照先集約が未処理ならば後回し
                    var notEnumerated = rest.Where(agg => next.refTargets.Contains(agg.root));
                    if (notEnumerated.Any()) {
                        // 集約間の循環参照が存在するなどの場合は無限ループが発生するので例外。
                        // なお循環参照はスキーマ作成時にエラーとする想定
                        if (index + 1 >= rest.Count) throw new InvalidOperationException("集約間のデータの流れを決定できません。");

                        index++;
                        continue;
                    }

                    // 参照先集約が無い == nextは現在のrestの中で再上流の集約
                    _rootAggregateOrderCache.Add(next.root, _rootAggregateOrderCache.Count);

                    rest.Remove(next);
                    index = 0;
                }
            }
            return rootAggregates.OrderBy(r => _rootAggregateOrderCache![r]);
        }
        private Dictionary<RootAggregate, int>? _rootAggregateOrderCache;
        #endregion ToOrderedByDataFlow


        /// <summary>
        /// 文字種を列挙
        /// </summary>
        internal IEnumerable<string> GetCharacterTypes() {
            return _characterTypes ??= _immutableSchema
                .GetRootAggregates()
                .SelectMany(root => root.EnumerateThisAndDescendants())
                .SelectMany(agg => agg.GetMembers())
                .OfType<ValueMember>()
                .Where(vm => vm.CharacterType != null)
                .Select(vm => vm.CharacterType!)
                .ToArray();
        }
        private string[]? _characterTypes;
    }
}
