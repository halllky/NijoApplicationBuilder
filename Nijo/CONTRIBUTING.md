- [NijoApplicationBuilder の開発者に向けた記述](#nijoapplicationbuilder-の開発者に向けた記述)
  - [主要なプロジェクト構成、ファイル構成](#主要なプロジェクト構成ファイル構成)
  - [ビルド方法](#ビルド方法)
  - [デバッグ方法](#デバッグ方法)
  - [コーディング規約](#コーディング規約)
    - [.editorconfig](#editorconfig)
    - [ソースコードレンダリング処理](#ソースコードレンダリング処理)
      - [メソッド名](#メソッド名)
      - [分岐処理の記法](#分岐処理の記法)
      - [反復処理の記法](#反復処理の記法)
      - [ソースコードレンダリング処理の入れ子の記法](#ソースコードレンダリング処理の入れ子の記法)
    - [クラス・インターフェース・メンバー命名規則](#クラスインターフェースメンバー命名規則)
    - [エラー処理指針](#エラー処理指針)

# NijoApplicationBuilder の開発者に向けた記述

## 主要なプロジェクト構成、ファイル構成
このプロジェクト全体の大まかな構成については [README.md](./README.md) を参照してください。
その他、主要なフォルダはそのフォルダ内部に `README.md` が置かれています。そのフォルダがどういった責務を負っているかなどの概要が記載されているので参照するようにしてください。

## ビルド方法
通常の .NET Core のビルド方法でビルド可能です。
Visual Studio からビルドしたり、 `dotnet build -c Debug` でビルドしたりしてください。

## デバッグ方法
当プロジェクトの動作確認には以下の手段を用いることができます。

- [テンプレートプロジェクト](../Nijo.ApplicationTemplate.Ver1/) では、自動生成されたソースコードを利用した完全なアプリケーションの動作確認を行なうことができます。
  - 当該プロジェクトに対して `nijo.exe generate` コマンドや `nijo.exe run` コマンドを実行し、動作確認を行なうことができます。
- [ユニットテスト](../Nijo.IntegrationTest/) では、NUnitを用いてソースコード自動生成処理の動作確認を行なうことができます。
  - 実行方法は通常のNUnitのテストの実行方法と同一のためここでは記載を割愛します。
  - テストの実行にあたり事前に準備しなければならないことはありません。
  - ユニットテストはWindowsで動作します。他のOSでは期待通り動作しない可能性があります。

基本的にはテンプレートプロジェクトで自動生成を試して動作確認を行います。
アプリケーションテンプレートのスキーマ定義は、出現しうるデータ構造を網羅するように作られています。

それでカバーできないパターン（例えば集約が1個も定義されていないnijo.xmlなど）は、ユニットテストでカバーしています。

## コーディング規約

### .editorconfig
ファイルの改行コードや `{` の位置などのフォーマットは [.editorconfig](../.editorconfig) に準拠します。
人間がソース修正を行なう場合は必ず .editorconfig によるオートフォーマットが効くエディタを使用します。

### ソースコードレンダリング処理
ソースコードレンダリング処理とは、C#の生文字列リテラル(Raw String Literal)( `$$"""` ～ `"""` )を用いて複数行にわたるソースコードレンダリングを行うメソッドを指します。
このプロジェクトにおけるソースコードレンダリング処理は以下のルールに準拠します。

#### メソッド名
`Render` から始まるメソッド名を持ちます。

#### 分岐処理の記法
何らかの条件に基づいて特定のソースをレンダリングするか否かが分かれる場合は [TemplateTextHelper](./CodeGenerating/TemplateTextHelper.cs) で定義されている `If()` , `.ElseIf()` , `.Else()` を使用してください。
また、それらのソースは、C#のテンプレートリテラルの構文の末尾の `"""` の位置とインデントを合わせて下さい。

OK

```cs
string RenderXXX() {
    return $$"""
        // ここに何らかのソースをレンダリングする
        {{If(/* 条件A */, () => $$"""
            // 条件Aを満たした場合のみレンダリングされるソース
        """).ElseIf(/* 条件B */, () => $$"""
            // 条件Bを満たした場合のみレンダリングされるソース
        """).Else(() => $$"""
            // 条件A, B いずれも満たさない場合のみレンダリングされるソース
        """)}}
        """;
}
```

NG

```cs
string RenderXXX() {
    return $$"""
        // ここに何らかのソースをレンダリングする
            {{If(/* 条件A */, () => $$"""
            // 条件Aを満たした場合のみレンダリングされるソース
            """).ElseIf(/* 条件B */, () => $$"""
            // 条件Bを満たした場合のみレンダリングされるソース
            """).Else(() => $$"""
            // 条件A, B いずれも満たさない場合のみレンダリングされるソース
            """)}}
        """;
}
```

#### 反復処理の記法
何らかの条件に基づいて特定のソースを反復処理する場合は `.SelectTextTemplate` メソッドを使ってください。
また、それらのソースは、C#のテンプレートリテラルの構文の末尾の `"""` の位置とインデントを合わせて下さい。

OK

```cs
string RenderXXX() {
    var array = Enumerable.Range(0, 4).Select(_ => "あ");
    return $$"""
        // ここに何らかのソースをレンダリングする
        {{array.SelectTextTemplate((_, i) => $$"""
            // {{i + 1}}番目の要素です。
        """)}}
        """;
}
```

NG

```cs
string RenderXXX() {
    var array = Enumerable.Range(0, 4).Select(_ => "あ");
    return $$"""
        // ここに何らかのソースをレンダリングする
            {{array.SelectTextTemplate((_, i) => $$"""
                // {{i + 1}}番目の要素です。
            """)}}
        """;
}
```

#### ソースコードレンダリング処理の入れ子の記法
ソースコードレンダリング処理の中で他のソースコードレンダリング処理を呼び出す際は、呼び出す側で `WithIndent` を用いてインデントを合わせます。
`WithIndent` の第2引数には、その行のインデントのサイズと等しい数の半角スペースを渡してください。

OK

```cs
string RenderXXX(object root) {
    return $$"""
        {{GetSomeChildren(root).SelectTextTemplate((x, i) => $$"""
          {{WithIndent(RenderTypeScriptObjectTypeRecursively(x), "  ")}}
        """)}}
        """;

    string RenderTypeScriptObjectTypeRecursively(object obj) {
        return $$"""
            {
            {{GetSomeChildren(obj).SelectTextTemplate(x => $$"""
              {{WithIndent(RenderTypeScriptObjectTypeRecursively(x), "  ")}}
            """)}}
            }
            """;
    }
}
```

### クラス・インターフェース・メンバー命名規則
- クラス名およびインターフェース名はパスカルケース（例: `DisplayDataValueMember`）で記述します
- インターフェース名は `I` プレフィックスを付けます（例: `IDisplayDataMember`）
- 列挙型は基本的に `E_` プレフィックスを付けます（例: `E_Type`）
- プライベートフィールドには `_` プレフィックスを付けます（例: `_aggregate`）
- 定数名は大文字のスネークケースで記述します（例: `VERSION`, `CREATE_USER`）
- プロパティ名はパスカルケース（例: `PhysicalName`, `CsClassName`）で記述します

### エラー処理指針
- スキーマ解析の処理中では、不正なスキーマ定義の存在がありうるため、例外が発生しないようにします。
- コード生成の処理中では、不正なスキーマ定義は全て排除されていることを前提としてよいため、オブジェクトが想定外の状態をとる場合は積極的に例外を送出してください。
