using Nijo.CodeGenerating;
using Nijo.ImmutableSchema;
using Nijo.Models.QueryModelModules;
using Nijo.Parts.Common;
using Nijo.Parts.CSharp;
using Nijo.Util.DotnetEx;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nijo.Models.DataModelModules {
    internal class BatchUpdate {
        internal BatchUpdate(RootAggregate rootAggregate) {
            _rootAggregate = rootAggregate;
        }

        private readonly RootAggregate _rootAggregate;
        private const string APP_SRV_METHOD = "BatchUpdateAsync";
        private string AppSrvArgType => new DisplayData(_rootAggregate).CsClassName;

        private const string CONTROLLER_ACTION = "batch-update";

        internal static string RenderTsTypeMap(IEnumerable<RootAggregate> dataModels) {
            var items = dataModels
                .Where(root => root.GenerateBatchUpdateCommand)
                .Select(rootAggregate => {
                    var batchUpdate = new BatchUpdate(rootAggregate);
                    var controller = new AspNetController(rootAggregate);

                    return new {
                        EscapedPhysicalName = rootAggregate.PhysicalName.Replace("'", "\\'"),
                        ParamType = batchUpdate.AppSrvArgType,
                        Endpoint = controller.GetActionNameForClient(CONTROLLER_ACTION),
                    };
                });

            return $$"""
                /** 一括更新処理 */
                export namespace BatchUpdateFeature {
                  /** 一括更新処理のURLエンドポイントの一覧 */
                  export const Endpoint: { [key in {{CommandQueryMappings.BATCH_UPDATABLE_QUERY_MODEL_TYPE}}]: string } = {
                {{items.SelectTextTemplate(x => $$"""
                    '{{x.EscapedPhysicalName}}': '{{x.Endpoint}}',
                """)}}
                  }

                  /** 一覧検索処理のパラメータ型一覧 */
                  export interface ParamType {
                {{items.SelectTextTemplate(x => $$"""
                    '{{x.EscapedPhysicalName}}': {{x.ParamType}}[]
                """)}}
                  }
                }
                """;
        }

        internal string RenderControllerAction(CodeRenderingContext ctx) {
            var displayData = new DisplayData(_rootAggregate);
            var displayDataMessages = new DisplayDataMessageContainer(_rootAggregate);

            return $$"""
                /// <summary>
                /// {{_rootAggregate.DisplayName}}の一覧検索処理のエンドポイント
                /// </summary>
                [HttpPost("{{CONTROLLER_ACTION}}"), {{AspNetController.AUTOGENERATED_ENDPOINT}}({{CommandQueryMappings.E_COMMAND_QUERY_TYPE}}.{{_rootAggregate.PhysicalName}}, {{E_AutoGeneratedActionType.ENUM_NAME}}.{{E_AutoGeneratedActionType.READ}})]
                public async Task<IActionResult> Load(
                    [ModelBinder(BinderType = typeof(DataModelBinder<>))] List<{{displayData.CsClassName}}> {{AspNetController.DATA}},
                    [ModelBinder(BinderType = typeof(ContextModelBinder<>))] {{PresentationContext.INTERFACE}}<{{MessageContainer.CONCRETE_CLASS_LIST}}<{{displayDataMessages.CsClassName}}>> {{AspNetController.CONTEXT}}) {
                    await _applicationService.{{APP_SRV_METHOD}}(data.ToArray(), context);
                    return _webConfigure.{{AspNetController.TO_ACTION_RESULT}}(null, context);
                }
                """;
        }

        internal string RenderAppSrvMethod(CodeRenderingContext ctx) {
            var displayData = new DisplayData(_rootAggregate);
            var displayDataMssage = new DisplayDataMessageContainer(_rootAggregate);

            var createMethod = new CreateMethod(_rootAggregate);
            var updateMethod = new UpdateMethod(_rootAggregate);
            var deleteMethod = new DeleteMethod(_rootAggregate);

            var createCommand = new SaveCommand(_rootAggregate, SaveCommand.E_Type.Create);
            var udpateCommand = new SaveCommand(_rootAggregate, SaveCommand.E_Type.Update);
            var deleteCommand = new SaveCommand(_rootAggregate, SaveCommand.E_Type.Delete);

            return $$"""
                /// <summary>
                /// {{_rootAggregate.DisplayName}}の画面表示用データの一括更新を行ないます。
                /// </summary>
                /// <param name="displayDataItems">
                /// 更新データ。追加・更新・削除のいずれかはデータの内容を見て判断されます。
                /// いずれか1件でもエラーが発生した場合、すべての要素の更新がロールバックされます。
                /// 途中でエラーが発生した場合でも残りの要素のエラーチェックまでは実行されます。
                /// </param>
                /// <param name="context">エラーメッセージや更新オプションの情報を持ったコンテキスト引数</param>
                public virtual async Task {{APP_SRV_METHOD}}({{AppSrvArgType}}[] displayDataItems, {{PresentationContext.INTERFACE}}<{{MessageContainer.CONCRETE_CLASS_LIST}}<{{displayDataMssage.CsClassName}}>> context) {
                    // エラーチェックのみの1巡目処理の場合はトランザクションを開始しない。
                    // なお、DataModelの登録更新処理では、トランザクションが開始されないまま更新実行しようとすると、即時コミットではなくエラーになる。
                    using var tran = context.Options.IgnoreConfirm
                        ? await DbContext.Database.BeginTransactionAsync()
                        : null;

                    for (int i = 0; i < displayDataItems.Length; i++) {
                        var displayData = displayDataItems[i];

                        if (!displayData.ExistsInDatabase) {
                            // 追加
                            var createCommand = displayData.{{DisplayData.TO_CREATE_COMMAND}}();
                            await {{createMethod.MethodName}}(createCommand, context.Messages[i], context);

                        } else if (displayData.WillBeDeleted) {
                            // 削除
                            var deleteCommand = displayData.{{DisplayData.TO_DELETE_COMMAND}}();
                            await {{deleteMethod.MethodName}}(deleteCommand, context.Messages[i], context);

                        } else if (displayData.WillBeChanged) {
                            // 更新
                            var updateCommand = displayData.{{DisplayData.TO_UPDATE_COMMAND}}();
                            await {{updateMethod.MethodName}}(updateCommand, context.Messages[i], context);

                        } else {
                            // 変更なし
                        }
                    }

                    // エラーチェックのみの1巡目処理の場合はここで終了
                    if (!context.Options.IgnoreConfirm) {
                        return;
                    }

                    // 1件でもエラーがあればロールバック
                    if (context.Messages.HasError()) {
                        await tran!.RollbackAsync();
                    } else {
                        await tran!.CommitAsync();
                    }
                }
                """;
        }
    }
}
