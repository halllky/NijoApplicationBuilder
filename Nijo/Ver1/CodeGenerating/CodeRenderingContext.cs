using Nijo.Ver1.SchemaParsing;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace Nijo.Ver1.CodeGenerating {
    /// <summary>
    /// ソースコード自動生成のコンテキスト情報
    /// </summary>
    public sealed class CodeRenderingContext : IMultiAggregateSourceFileManager {
        internal CodeRenderingContext(GeneratedProject project, ApplicationConfig config, SchemaParseContext xmlParseContext) {
            Project = project;
            Config = config;
            SchemaParser = xmlParseContext;
        }

        public GeneratedProject Project { get; }
        public ApplicationConfig Config { get; }

        private const string AUTOGENERATED_CORE = "__AutoGenerated";
        private const string AUTOGENERATED_WEBAPI = "__AutoGenerated";
        private const string AUTOGENERATED_REACT = "__autoGenerated";

        /// <summary>
        /// C#のクラスライブラリのソースコード自動生成フォルダのルート。
        /// コードが自動生成される主たるプロジェクト。
        /// </summary>
        public void CoreLibrary(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.CoreLibrary, dir => {
                dir.Directory(AUTOGENERATED_CORE, setup);
            });
        }
        /// <summary>
        /// ASP.NET Core プロジェクトのソースコード自動生成フォルダのルート。
        /// </summary>
        public void WebapiProject(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.WebapiProject, dir => {
                dir.Directory(AUTOGENERATED_WEBAPI, setup);
            });
        }
        /// <summary>
        /// React.js プロジェクトのソースコード自動生成フォルダのルート。
        /// </summary>
        public void ReactProject(Action<DirectorySetupper> setup) {
            DirectorySetupper.StartSetup(this, Project.ReactProject, dir => {
                dir.Directory("src", srcDir => {
                    srcDir.Directory(AUTOGENERATED_REACT, setup);
                });
            });
        }


        #region 集約定義の解釈ルール
        /// <inheritdoc cref="SchemaParseContext"/>
        internal SchemaParseContext SchemaParser { get; }
        #endregion 集約定義の解釈ルール


        #region 複数の集約からレンダリングされるソースファイルの管理
        /// <inheritdoc cref="IMultiAggregateSourceFileManager.Use{T}"/>
        public T Use<T>() where T : IMultiAggregateSourceFile, new() {
            if (_stopUseMultiAggregateSourceFiles) {
                throw new InvalidOperationException($"{nameof(IMultiAggregateSourceFile)} のレンダリング中に {nameof(Use)} が呼ばれた可能性があります。");
            }

            var instance = _multiAggregateSources.OfType<T>().SingleOrDefault();
            if (instance == null) {
                instance = new T();
                _multiAggregateSources.Add(instance);
            }

            return instance;
        }
        /// <summary>
        /// 複数の集約から1つのファイルが生成される類のファイルを返します。
        /// </summary>
        internal IEnumerable<IMultiAggregateSourceFile> GetMultiAggregateSourceFiles() {
            return _multiAggregateSources;
        }
        /// <summary>
        /// <see cref="IMultiAggregateSourceFile"/> のレンダリング開始後に
        /// <see cref="Use{T}"/> が呼ばれてしまうとレンダリングが実行されない可能性があるため
        /// このメソッドが呼ばれた後は <see cref="Use{T}"/> 使用不可
        /// </summary>
        internal void StopUseMultiAggregateSourceFiles() {
            _stopUseMultiAggregateSourceFiles = true;
        }

        private readonly HashSet<IMultiAggregateSourceFile> _multiAggregateSources = [];
        private bool _stopUseMultiAggregateSourceFiles = false;
        #endregion 複数の集約からレンダリングされるソースファイルの管理


        #region ソースコード自動生成で登場しなかった既存ファイルの削除
        private readonly HashSet<string> _handled = new();
        internal void Handle(string fullpath) => _handled.Add(Path.GetFullPath(fullpath));
        /// <summary>
        /// このコンテキストで生成されていないファイルやディレクトリを削除します。
        /// </summary>
        internal void CleanUnhandledFilesAndDirectories() {
            var allFiles = new List<string>();
            var core = Path.Combine(Project.CoreLibrary, AUTOGENERATED_CORE);
            var webapi = Path.Combine(Project.WebapiProject, AUTOGENERATED_WEBAPI);
            var react = Path.Combine(Project.ReactProject, "src", AUTOGENERATED_REACT);
            if (Directory.Exists(core)) allFiles.AddRange(Directory.GetFiles(core, "*", SearchOption.AllDirectories));
            if (Directory.Exists(webapi)) allFiles.AddRange(Directory.GetFiles(webapi, "*", SearchOption.AllDirectories));
            if (Directory.Exists(react)) allFiles.AddRange(Directory.GetFiles(react, "*", SearchOption.AllDirectories));

            foreach (var file in allFiles) {
                if (_handled.Contains(Path.GetFullPath(file))) continue;
                if (!File.Exists(file)) continue;
                File.Delete(file);
            }

            var allDirectories = new List<string>();
            if (Directory.Exists(core)) allDirectories.AddRange(Directory.GetDirectories(core, "*", SearchOption.AllDirectories));
            if (Directory.Exists(webapi)) allDirectories.AddRange(Directory.GetDirectories(webapi, "*", SearchOption.AllDirectories));
            if (Directory.Exists(react)) allDirectories.AddRange(Directory.GetDirectories(react, "*", SearchOption.AllDirectories));

            foreach (var dir in allDirectories) {
                if (_handled.Contains(Path.GetFullPath(dir))) continue;
                if (!Directory.Exists(dir)) continue;
                Directory.Delete(dir, true);
            }
        }
        #endregion ソースコード自動生成で登場しなかった既存ファイルの削除
    }
}
